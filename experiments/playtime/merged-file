-- main.lua
package.path = package.path .. ";../../?.lua"

-- todo extract jsut the camera stuff i need nowadasy from these files and wrap it in one package
local cam = require('lib.cameraBase').getInstance()
local camera = require 'lib.camera'
-- todo extract just the routines i need nowadays.. (render box2d world debug draw, something about pointer)
local phys = require 'lib.mainPhysics'
local blob = require 'vendor.loveblobs'
local inspect = require 'vendor.inspect'

local ui = require 'src.ui-all'
local joint = require 'src.joints'
local selectrect = require 'src.selection-rect'
local io = require 'src.io'
local registry = require 'src.registry'
local script = require 'src.script'
local objectManager = require 'src.object-manager'
local mathutil = require 'src.math-utils'
local utils = require 'src.utils'

local box2dDraw = require 'src.box2d-draw'
-- todo, jointhandlers, dont really reuse properties after flip..
--
function waitForEvent()
    local a, b, c, d, e
    repeat
        a, b, c, d, e = love.event.wait()
    until a == "focus" or a == 'mousepressed' or a == 'touchpressed'
end

waitForEvent()

local PANEL_WIDTH = 300
local BUTTON_HEIGHT = 40
local ROW_WIDTH = 160
local BUTTON_SPACING = 10
local FIXED_TIMESTEP = true
local TICKRATE = 1 / 60

function love.load()
    -- Load and set the font
    local font = love.graphics.newFont('assets/cooper_bold_bt.ttf', 30)
    love.keyboard.setKeyRepeat(true)
    love.graphics.setFont(font)

    -- Initialize UI
    ui.init(font)

    uiState = {
        lastUsedRadius = 20,
        lastUsedWidth = 40,
        lastUsedHeight = 40,
        showGrid = false,
        radiusOfNextSpawn = 100,
        nextType = 'dynamic',
        addShapeOpened = false,
        addJointOpened = false,
        worldSettingsOpened = false,
        maybeHideSelectedPanel = false,
        selectedJoint = nil,
        setOffsetAFunc = nil,
        setOffsetBFunc = nil,
        selectedObj = nil,
        draggingObj = nil,
        offsetDragging = { nil, nil },
        worldText = '',
        jointCreationMode = nil,
        jointUpdateMode = nil,
        drawFreePoly = false,
        drawClickPoly = false,
        capturingPoly = false,
        polyLockedVerts = true,
        polyDragIdx = 0,
        polyTempVerts = nil, -- used when dragging a vertex
        polyCentroid = nil,
        polyVerts = {},
        minPointDistance = 50, -- Default minimum distance
        lastPolyPt = nil,
        lastSelectedBody = nil,
        selectedBodies = nil,
        lastSelectedJoint = nil,
        saveDialogOpened = false,
        saveName = 'untitled'
    }

    worldState = {
        meter = 100,
        paused = true,
        gravity = 9.80,
        mouseForce = 500000,
        mouseDamping = 0.5
    }

    sceneScript = nil


    love.physics.setMeter(worldState.meter)
    --world = love.physics.newWorld(0, worldState.gravity * love.physics.getMeter(), true)
    phys.setupWorldWithGravity(worldState.meter, worldState.gravity)

    local w, h = love.graphics.getDimensions()
    camera.setCameraViewport(cam, w, h)
    camera.centerCameraOnPosition(325, 325, 2000, 2000)

    objectManager.addThing('rectangle', 200, 400, 'dynamic', 100, 400)
    -- objectManager.addThing('rectangle', 600, 400, 'dynamic', 100)
    -- objectManager.addThing('rectangle', 450, 800, 'kinematic', 200)
    -- objectManager.addThing('rectangle', 850, 800, 'static', 200)
    -- objectManager.addThing('rectangle', 250, 1000, 'static', 100, 1800)
    -- objectManager.addThing('rectangle', 1100, 100, 'dynamic', 300)
    -- objectManager.addThing('circle', 1000, 400, 'dynamic', 100)
    -- objectManager.addThing('circle', 1300, 400, 'dynamic', 100)


    -- -- Adding custom polygon
    local customVertices = {
        0, 0,
        100, 0,
        200, 100,
        50, 500,
        -- Add more vertices as needed
    }
    objectManager.addThing('custom', 500, 500, 'dynamic', nil, nil, nil, 'CustomShape', customVertices)

    softbodies = {}

    playWithSoftbodies = false
    if playWithSoftbodies then
        local b = blob.softbody(world, 500, 0, 102, 2, 4)
        b:setFrequency(1)
        b:setDamping(0.1)
        b:setFriction(1)

        table.insert(softbodies, b)
        local points = {
            0, 500, 800, 500,
            800, 800, 0, 800
        }
        local b = blob.softsurface(world, points, 64, "static")
        table.insert(softbodies, b)
    end
end

function finalizePolygon()
    if #uiState.polyVerts >= 6 then
        local cx, cy = mathutil.computeCentroid(uiState.polyVerts)
        objectManager.addThing('custom', cx, cy, uiState.nextType, nil, nil, nil, '', uiState.polyVerts)
    else
        -- Not enough vertices to form a polygon
        print("Not enough vertices to create a polygon.")
    end
    -- Reset the drawing state
    uiState.drawClickPoly = false
    uiState.drawFreePoly = false
    uiState.capturingPoly = false
    uiState.polyVerts = {}
    uiState.lastPolyPt = nil
end

function love.update(dt)
    if not worldState.paused then
        -- for i, v in ipairs(softbodies) do
        --     v:update(dt)
        -- end

        for i = 1, 1 do
            world:update(dt)
        end

        if sceneScript and sceneScript.update then
            sceneScript.update()
        end
    end
    phys.handleUpdate(dt)

    if uiState.draggingObj then
        local mx, my = love.mouse.getPosition()
        local wx, wy = cam:getWorldCoordinates(mx, my)
        local offx = uiState.offsetDragging[1]
        local offy = uiState.offsetDragging[2]
        local rx, ry = mathutil.rotatePoint(offx, offy, 0, 0, uiState.draggingObj.body:getAngle())
        local oldPosX, oldPosY = uiState.draggingObj.body:getPosition()
        uiState.draggingObj.body:setPosition(wx + rx, wy + ry)

        -- figure out if we are dragging a group!
        if uiState.selectedBodies then
            for i = 1, #uiState.selectedBodies do
                if (uiState.selectedBodies[i] == uiState.draggingObj) then
                    local newPosX, newPosY = uiState.draggingObj.body:getPosition()
                    local dx = newPosX - oldPosX
                    local dy = newPosY - oldPosY
                    for j = 1, #uiState.selectedBodies do
                        if (uiState.selectedBodies[j] ~= uiState.draggingObj) then
                            local oldPosX, oldPosY = uiState.selectedBodies[j].body:getPosition()
                            uiState.selectedBodies[j].body:setPosition(oldPosX + dx, oldPosY + dy)
                        end
                    end
                end
            end
        end
    end
end

local function drawAddShapeUI()
    local shapeTypes = { 'circle', 'triangle', 'itriangle', 'capsule', 'trapezium', 'rectangle', 'pentagon',
        'hexagon',
        'heptagon',
        'octagon' }
    local titleHeight = ui.font:getHeight() + BUTTON_SPACING
    local startX = 20
    local startY = 70
    local panelWidth = 200
    local buttonSpacing = BUTTON_SPACING
    local buttonHeight = ui.theme.button.height
    local panelHeight = titleHeight + ((#shapeTypes + 3) * (buttonHeight + buttonSpacing)) + buttonSpacing

    ui.panel(startX, startY, panelWidth, panelHeight, '', function()
        local layout = ui.createLayout({
            type = 'columns',
            spacing = BUTTON_SPACING,
            startX = startX + BUTTON_SPACING,
            startY = startY + BUTTON_SPACING
        })

        local x, y = ui.nextLayoutPosition(layout, panelWidth - 20, buttonHeight)
        local bodyTypes = { 'dynamic', 'kinematic', 'static' }
        if ui.button(x, y, 180, uiState.nextType) then
            local index = -1
            for i, v in ipairs(bodyTypes) do
                if uiState.nextType == v then
                    index = i
                end
            end
            uiState.nextType = bodyTypes[index % #bodyTypes + 1]
        end

        for _, shape in ipairs(shapeTypes) do
            local width = panelWidth - 20
            local height = buttonHeight
            x, y = ui.nextLayoutPosition(layout, width, height)
            local _, pressed, released = ui.button(x, y, width, shape)
            if pressed then
                ui.draggingActive = ui.activeElementID
                local mx, my = love.mouse.getPosition()
                local wx, wy = cam:getWorldCoordinates(mx, my)
                objectManager.startSpawn(shape, wx, wy)
            end
            if released then
                ui.draggingActive = nil
            end
        end

        local width = panelWidth - 20
        local height = buttonHeight
        x, y = ui.nextLayoutPosition(layout, width, height)
        local minDist = ui.sliderWithInput('minDistance', x, y, 80, 1, 150, uiState.minPointDistance or 10)
        ui.label(x, y, 'dis')
        if minDist then
            uiState.minPointDistance = minDist
        end

        -- Add a button for custom polygon
        x, y = ui.nextLayoutPosition(layout, width, height)
        if ui.button(x, y, width, 'freeform') then
            uiState.drawFreePoly = true
            uiState.polyVerts = {}
            uiState.lastPolyPt = nil
        end

        x, y = ui.nextLayoutPosition(layout, width, height)
        if ui.button(x, y, width, 'click') then
            uiState.drawClickPoly = true
            uiState.polyVerts = {}
            uiState.lastPolyPt = nil
        end
    end)
end

local function drawUpdateSelectedObjectUI()
    local panelWidth = PANEL_WIDTH
    local w, h = love.graphics.getDimensions()
    ui.panel(w - panelWidth - 20, 20, panelWidth, h - 40, '∞ body props ∞', function()
        local body = uiState.selectedObj.body
        -- local angleDegrees = body:getAngle() * 180 / math.pi
        local myID = uiState.selectedObj.id

        -- Initialize Layout
        local padding = BUTTON_SPACING
        local layout = ui.createLayout({
            type = 'columns',
            spacing = BUTTON_SPACING,
            startX = w - panelWidth,
            startY = 100 + padding
        })

        -- Toggle Body Type Button
        -- Retrieve the current body type
        local currentBodyType = body:getType() -- 'static', 'dynamic', or 'kinematic'

        -- Determine the next body type in the cycle
        local nextBodyType
        if currentBodyType == 'static' then
            nextBodyType = 'dynamic'
        elseif currentBodyType == 'dynamic' then
            nextBodyType = 'kinematic'
        elseif currentBodyType == 'kinematic' then
            nextBodyType = 'static'
        end

        -- Add a button to toggle the body type
        x, y = ui.nextLayoutPosition(layout, ROW_WIDTH, BUTTON_HEIGHT)

        local nextRow = function()
            x, y = ui.nextLayoutPosition(layout, ROW_WIDTH, BUTTON_HEIGHT)
        end
        if ui.button(x, y, 260, currentBodyType) then
            body:setType(nextBodyType)
            body:setAwake(true)
        end

        local userData = body:getUserData()
        local thing = userData and userData.thing

        local dirtyBodyChange = false
        if (uiState.lastSelectedBody ~= body) then
            dirtyBodyChange = true
            uiState.lastSelectedBody = body
        end

        if thing then
            -- Shape Properties
            local shapeType = thing.shapeType

            -- Label Editor
            nextRow()
            if ui.button(x, y, 120, 'flipX') then
                uiState.selectedObj = objectManager.flipThing(thing, 'x', true)
                dirtyBodyChange = true
            end
            if ui.button(x + 140, y, 120, 'flipY') then
                uiState.selectedObj = objectManager.flipThing(thing, 'y', true)
                dirtyBodyChange = true
            end
            nextRow()
            local newLabel = ui.textinput(myID .. ' label', x, y, 260, 40, "", thing.label)
            if newLabel and newLabel ~= thing.label then
                thing.label = newLabel -- Update the label
            end

            nextRow()

            if shapeType == 'circle' then
                -- Show radius control for circles
                nextRow()

                local newRadius = ui.sliderWithInput(myID .. ' radius', x, y, ROW_WIDTH, 1, 200, thing.radius)
                ui.label(x, y, ' radius')
                if newRadius and newRadius ~= thing.radius then
                    uiState.selectedObj = objectManager.recreateThingFromBody(body,
                        { shapeType = "circle", radius = newRadius })
                    uiState.lastUsedRadius = newRadius
                    body = uiState.selectedObj.body
                end
            elseif shapeType == 'rectangle' or shapeType == 'capsule' or shapeType == 'trapezium' or shapeType == 'itriangle' then
                -- Show width and height controls for these shapes
                nextRow()

                local newWidth = ui.sliderWithInput(myID .. ' width', x, y, ROW_WIDTH, 1, 800, thing.width)
                ui.label(x, y, ' width')
                nextRow()

                local newHeight = ui.sliderWithInput(myID .. ' height', x, y, ROW_WIDTH, 1, 800, thing.height)
                ui.label(x, y, ' height')

                if (newWidth and newWidth ~= thing.width) or (newHeight and newHeight ~= thing.height) then
                    uiState.lastUsedWidth = newWidth
                    uiState.lastUsedHeight = newHeight
                    uiState.selectedObj = objectManager.recreateThingFromBody(body, {
                        shapeType = shapeType,
                        width = newWidth or thing.width,
                        height = newHeight or thing.height,
                    })
                    body = uiState.selectedObj.body
                end
            else
                -- For polygonal or other custom shapes, only allow radius control if applicable
                if shapeType == 'triangle' or shapeType == 'pentagon' or shapeType == 'hexagon' or
                    shapeType == 'heptagon' or shapeType == 'octagon' then
                    nextRow()

                    local newRadius = ui.sliderWithInput(myID .. ' radius', x, y, ROW_WIDTH, 1, 200, thing.radius,
                        dirtyBodyChange)
                    ui.label(x, y, ' radius')
                    if newRadius and newRadius ~= thing.radius then
                        uiState.selectedObj = objectManager.recreateThingFromBody(body,
                            { shapeType = shapeType, radius = newRadius })
                        uiState.lastUsedRadius = newRadius
                        body = uiState.selectedObj.body
                    end
                else
                    -- No UI controls for custom or unsupported shapes
                    --ui.label(x, y, 'custom')
                    if ui.button(x, y, 260, uiState.polyLockedVerts and 'verts locked' or 'verts unlocked') then
                        uiState.polyLockedVerts = not uiState.polyLockedVerts
                        if uiState.polyLockedVerts == false then
                            uiState.polyTempVerts = utils.shallowCopy(uiState.selectedObj.vertices)
                            local cx, cy = mathutil.computeCentroid(uiState.selectedObj.vertices)
                            uiState.polyCentroid = { x = cx, y = cy }
                        else
                            uiState.polyTempVerts = nil
                            uiState.polyCentroid = nil
                        end
                    end
                end
            end
        end
        nextRow()

        local dirty, checked = ui.checkbox(x, y, body:isFixedRotation(), 'fixed angle')
        if dirty then
            body:setFixedRotation(not body:isFixedRotation())
        end

        -- Angle Slider
        nextRow()

        local newAngle = ui.sliderWithInput(myID .. 'angle', x, y, ROW_WIDTH, -180, 180,
            (body:getAngle() * 180 / math.pi),
            (body:isAwake() and not worldState.paused) or dirtyBodyChange)
        if newAngle and (body:getAngle() * 180 / math.pi) ~= newAngle then
            body:setAngle(newAngle * math.pi / 180)
        end
        ui.label(x, y, ' angle')

        -- Density Slider
        local fixtures = body:getFixtures()
        if #fixtures >= 1 then
            local density = fixtures[1]:getDensity()
            nextRow()

            local newDensity = ui.sliderWithInput(myID .. 'density', x, y, ROW_WIDTH, 0, 10, density)
            if newDensity and density ~= newDensity then
                for i = 1, #fixtures do
                    fixtures[i]:setDensity(newDensity)
                end
            end
            ui.label(x, y, ' density')

            -- Bounciness Slider
            local bounciness = fixtures[1]:getRestitution()
            nextRow()

            local newBounce = ui.sliderWithInput(myID .. 'bounce', x, y, ROW_WIDTH, 0, 1, bounciness)
            if newBounce and bounciness ~= newBounce then
                for i = 1, #fixtures do
                    fixtures[i]:setRestitution(newBounce)
                end
            end
            ui.label(x, y, ' bounce')

            -- Friction Slider
            local friction = fixtures[1]:getFriction()
            nextRow()

            local newFriction = ui.sliderWithInput(myID .. 'friction', x, y, ROW_WIDTH, 0, 1, friction)
            if newFriction and friction ~= newFriction then
                for i = 1, #fixtures do
                    fixtures[i]:setFriction(newFriction)
                end
            end
            ui.label(x, y, ' friction')
        end
        nextRow()
        -- set sleeping allowed
        local dirty, checked = ui.checkbox(x, y, body:isSleepingAllowed(), 'sleep ok')
        if dirty then
            body:setSleepingAllowed(not body:isSleepingAllowed())
        end
        nextRow()
        -- angukar veloicity
        local angleDegrees = tonumber(math.deg(body:getAngularVelocity()))
        if math.abs(angleDegrees) < 0.001 then angleDegrees = 0 end
        local newAngle = ui.sliderWithInput(myID .. 'angv', x, y, ROW_WIDTH, -180, 180, angleDegrees,
            body:isAwake() and not worldState.paused)
        if newAngle and angleDegrees ~= newAngle then
            body:setAngularVelocity(math.rad(newAngle))
        end
        ui.label(x, y, ' ang-vel')

        nextRow()
        if ui.button(x, y, 260, 'destroy') then
            objectManager.destroyBody(body)

            uiState.selectedObj = nil
        end

        -- List Attached Joints Using Body:getJoints()
        if not body:isDestroyed() then
            local attachedJoints = body:getJoints()
            if attachedJoints and #attachedJoints > 0 and not (#attachedJoints == 1 and attachedJoints[1]:getType() == 'mouse') then
                ui.label(x, y + 60, '∞ joints ∞')
                nextRow()
                -- layout:nextRow()

                for _, joint in ipairs(attachedJoints) do
                    -- Display joint type and unique identifier for identification
                    local jointType = joint:getType()
                    local jointID = tostring(joint)
                    if (jointType ~= 'mouse') then
                        -- Display joint button
                        x, y = ui.nextLayoutPosition(layout, ROW_WIDTH, BUTTON_HEIGHT - 10)
                        local jointLabel = string.format("%s", jointType)

                        if ui.button(x, y, ROW_WIDTH, jointLabel) then
                            uiState.selectedJoint = joint
                            uiState.selectedObj = nil
                        end
                    end
                end
            end
        end
    end)
end

local function drawGrid(cam, worldState)
    local lw = love.graphics.getLineWidth()
    love.graphics.setLineWidth(1)
    love.graphics.setColor(1, 1, 1, .1)

    local w, h = love.graphics.getDimensions()
    local tlx, tly = cam:getWorldCoordinates(0, 0)
    local brx, bry = cam:getWorldCoordinates(w, h)
    local step = worldState.meter
    local startX = math.floor(tlx / step) * step
    local endX = math.ceil(brx / step) * step
    local startY = math.floor(tly / step) * step
    local endY = math.ceil(bry / step) * step

    for i = startX, endX, step do
        local x, _ = cam:getScreenCoordinates(i, 0)
        love.graphics.line(x, 0, x, h)
    end
    for i = startY, endY, step do
        local _, y = cam:getScreenCoordinates(0, i)
        love.graphics.line(0, y, w, y)
    end
    love.graphics.setLineWidth(lw)
    love.graphics.setColor(1, 1, 1)
end

function drawUI()
    ui.startFrame()
    local w, h = love.graphics.getDimensions()
    love.graphics.rectangle('line', 10, 10, w - 20, h - 20, 20, 20)

    -- "Add Shape" Button
    if ui.button(20, 20, 200, 'add shape') then
        uiState.addShapeOpened = not uiState.addShapeOpened
    end

    if uiState.addShapeOpened then
        drawAddShapeUI()
    end

    -- "Add Joint" Button
    if ui.button(230, 20, 200, 'add joint') then
        uiState.addJointOpened = not uiState.addJointOpened
    end

    if uiState.addJointOpened then
        local jointTypes = { 'distance', 'weld', 'rope', 'revolute', 'wheel', 'motor', 'prismatic', 'pulley' }
        local titleHeight = ui.font:getHeight() + BUTTON_SPACING
        local startX = 230
        local startY = 70
        local panelWidth = 200
        local buttonSpacing = BUTTON_SPACING
        local buttonHeight = ui.theme.button.height
        local panelHeight = titleHeight + (#jointTypes * (buttonHeight + BUTTON_SPACING))

        ui.panel(startX, startY, panelWidth, panelHeight, '', function()
            local layout = ui.createLayout({
                type = 'columns',
                spacing = buttonSpacing,
                startX = startX + BUTTON_SPACING,
                startY = startY + BUTTON_SPACING
            })
            for _, joint in ipairs(jointTypes) do
                local width = panelWidth - 20
                local height = buttonHeight
                local x, y = ui.nextLayoutPosition(layout, width, height)
                local jointStarted = ui.button(x, y, width, joint)
                if jointStarted then
                    uiState.jointCreationMode = { body1 = nil, body2 = nil, jointType = joint }
                end
            end
        end)
    end

    -- "World Settings" Button
    if ui.button(440, 20, 300, 'world settings') then
        uiState.worldSettingsOpened = not uiState.worldSettingsOpened
    end

    if uiState.worldSettingsOpened then
        local startX = 440
        local startY = 70
        local panelWidth = PANEL_WIDTH
        local panelHeight = 400
        local buttonSpacing = BUTTON_SPACING
        local titleHeight = ui.font:getHeight() + BUTTON_SPACING

        ui.panel(startX, startY, panelWidth, panelHeight, '• ∫ƒF world •', function()
            local layout = ui.createLayout({
                type = 'columns',
                spacing = BUTTON_SPACING,
                startX = startX + BUTTON_SPACING,
                startY = startY + titleHeight + BUTTON_SPACING
            })
            local width = panelWidth - BUTTON_SPACING * 2

            local x, y = ui.nextLayoutPosition(layout, width, BUTTON_HEIGHT)

            --  x, y = ui.nextLayoutPosition(layout, width, 50)
            local grav = ui.sliderWithInput('grav', x, y, ROW_WIDTH, -10, BUTTON_HEIGHT, worldState.gravity)
            if grav then
                worldState.gravity = grav
                if world then
                    world:setGravity(0, worldState.gravity * worldState.meter)
                end
            end
            ui.label(x, y, ' gravity')

            x, y = ui.nextLayoutPosition(layout, width, BUTTON_HEIGHT)
            local g, value = ui.checkbox(x, y, uiState.showGrid, 'grid') --showGrid = true,
            if g then
                uiState.showGrid = value
            end


            x, y = ui.nextLayoutPosition(layout, width, BUTTON_HEIGHT)
            local mouseForce = ui.sliderWithInput(' mouse F', x, y, ROW_WIDTH, 0, 1000000, worldState.mouseForce)
            if mouseForce then
                worldState.mouseForce = mouseForce
            end
            ui.label(x, y, ' mouse F')
            x, y = ui.nextLayoutPosition(layout, width, BUTTON_HEIGHT)
            local mouseDamp = ui.sliderWithInput(' damp', x, y, ROW_WIDTH, 0.001, 1, worldState.mouseDamping)
            if mouseDamp then
                worldState.mouseDamping = mouseDamp
            end
            ui.label(x, y, ' damp')

            x, y = ui.nextLayoutPosition(layout, width, BUTTON_HEIGHT)
            local t = ui.textinput('worldText', x, y, 280, 70, 'add text...', uiState.worldText)
            if t then
                uiState.worldText = t
            end
        end)
    end

    -- Play/Pause Button
    if ui.button(750, 20, 150, worldState.paused and 'play' or 'pause') then
        worldState.paused = not worldState.paused
    end

    if sceneScript and sceneScript.onStart then
        if ui.button(920, 20, 50, 'R') then
            -- todo actually reread the file itself!
            sceneScript.onStart()
        end
    end

    if uiState.selectedObj and not uiState.selectedJoint then
        drawUpdateSelectedObjectUI()
    end

    if uiState.drawClickPoly then
        local panelWidth = PANEL_WIDTH
        local w, h = love.graphics.getDimensions()
        ui.panel(w - panelWidth - 20, 20, panelWidth, h - 40, '∞ click draw vertex polygon ∞', function()
            local padding = BUTTON_SPACING
            local layout = ui.createLayout({
                type = 'columns',
                spacing = BUTTON_SPACING,
                startX = w - panelWidth,
                startY = 100 + padding
            })
            x, y = ui.nextLayoutPosition(layout, ROW_WIDTH, BUTTON_HEIGHT)
            if ui.button(x, y, 260, 'finalize') then
                finalizePolygon()
            end
        end)
    end

    if uiState.selectedBodies and #uiState.selectedBodies > 0 then
        local panelWidth = PANEL_WIDTH
        local w, h = love.graphics.getDimensions()
        ui.panel(w - panelWidth - 20, 20, panelWidth, h - 40, '∞ selection ∞', function()
            local padding = BUTTON_SPACING
            local layout = ui.createLayout({
                type = 'columns',
                spacing = BUTTON_SPACING,
                startX = w - panelWidth,
                startY = 100 + padding
            })

            x, y = ui.nextLayoutPosition(layout, ROW_WIDTH, BUTTON_HEIGHT)


            if ui.button(x, y, 260, 'clone') then
                local cloned = io.cloneSelection(uiState.selectedBodies)
                uiState.selectedBodies = cloned
            end
            x, y = ui.nextLayoutPosition(layout, ROW_WIDTH, BUTTON_HEIGHT)
            if ui.button(x, y, 260, 'destroy') then
                for i = #uiState.selectedBodies, 1, -1 do
                    objectManager.destroyBody(uiState.selectedBodies[i].body)
                end
                uiState.selectedBodies = nil
            end
            x, y = ui.nextLayoutPosition(layout, ROW_WIDTH, BUTTON_HEIGHT)
        end)
    end


    if uiState.jointCreationMode and uiState.jointCreationMode.body1 and uiState.jointCreationMode.body2 then
        joint.doJointCreateUI(uiState, 500, 100, 400, 150)
    end

    if uiState.selectedJoint then
        -- (w - panelWidth - 20, 20, panelWidth, h - 40
        joint.doJointUpdateUI(uiState, uiState.selectedJoint, w - PANEL_WIDTH - 20, 20, PANEL_WIDTH, h - 40)
    end

    if uiState.jointCreationMode and ((uiState.jointCreationMode.body1 == nil) or (uiState.jointCreationMode.body2 == nil)) then
        if (uiState.jointCreationMode.body1 == nil) then
            ui.panel(500, 100, 300, 100, '• pick 1st body •', function()
                local x = 510
                local y = 150
                local width = 280
                if ui.button(x, y, width, 'cancel') then
                    uiState.jointCreationMode = nil
                end
            end)
        elseif (uiState.jointCreationMode.body2 == nil) then
            ui.panel(500, 100, 300, 100, '• pick 2nd body •', function()
                local x = 510
                local y = 150
                local width = 280
                if ui.button(x, y, width, 'cancel') then
                    uiState.jointCreationMode = nil
                end
            end)
        end
    end

    if uiState.saveDialogOpened then
        love.graphics.setColor(0, 0, 0, 0.5)
        love.graphics.rectangle('fill', 0, 0, w, h)
        love.graphics.setColor(1, 1, 1)
        ui.panel(300, 300, w - 600, h - 600, '»»» save «««', function()
            local t = ui.textinput('savename', 320, 350, w - 640, 40, 'add text...', uiState.saveName)
            if t then
                uiState.saveName = utils.sanitizeString(t)
            end
            if ui.button(320, 500, 200, 'save') then
                uiState.saveDialogOpened = false
                io.save(world, worldState, uiState.saveName)
            end
            if ui.button(540, 500, 200, 'cancel') then
                uiState.saveDialogOpened = false
                love.system.openURL("file://" .. love.filesystem.getSaveDirectory())
            end
        end)
    end

    if ui.draggingActive then
        love.graphics.setColor(ui.theme.draggedElement.fill)
        local x, y = love.mouse.getPosition()
        love.graphics.circle('fill', x, y, 10)
        love.graphics.setColor(1, 1, 1)
    end
end

function love.draw()
    local w, h = love.graphics.getDimensions()
    love.graphics.clear(20 / 255, 5 / 255, 20 / 255)
    if uiState.showGrid then
        drawGrid(cam, worldState)
    end
    cam:push()

    box2dDraw.drawWorld(world)

    if sceneScript and sceneScript.draw then
        sceneScript.draw()
    end

    if uiState.selectedJoint and not uiState.selectedJoint:isDestroyed() then
        local x1, y1, x2, y2 = uiState.selectedJoint:getAnchors()
        love.graphics.circle('line', x1, y1, 10)
        love.graphics.line(x2 - 10, y2, x2 + 10, y2)
        love.graphics.line(x2, y2 - 10, x2, y2 + 10)
    end

    local lw = love.graphics.getLineWidth()
    for i, v in ipairs(softbodies) do
        love.graphics.setColor(50 * i / 255, 100 / 255, 200 * i / 255, .8)
        if (tostring(v) == "softbody") then
            v:draw("fill", false)
        else
            v:draw(false)
        end
    end
    love.graphics.setLineWidth(lw)
    love.graphics.setColor(1, 1, 1)

    -- draw to be drawn polygon
    if uiState.drawFreePoly or uiState.drawClickPoly then
        if (#uiState.polyVerts >= 6) then
            love.graphics.polygon('line', uiState.polyVerts)
        end
    end

    -- draw mousehandlers for dragging vertices
    if uiState.polyTempVerts and uiState.selectedObj and uiState.selectedObj.shapeType == 'custom' and uiState.polyLockedVerts == false then
        local verts = mathutil.getLocalVerticesForCustomSelected(uiState.polyTempVerts,
            uiState.selectedObj, uiState.polyCentroid.x, uiState.polyCentroid.y)

        local mx, my = love.mouse:getPosition()
        local cx, cy = cam:getWorldCoordinates(mx, my)

        for i = 1, #verts, 2 do
            local vx = verts[i]
            local vy = verts[i + 1]
            local dist = math.sqrt((cx - vx) ^ 2 + (cy - vy) ^ 2)
            if dist < 10 then
                love.graphics.circle('fill', vx, vy, 10)
            else
                love.graphics.circle('line', vx, vy, 10)
            end
        end
    end


    -- Highlight selected bodies
    if uiState.selectedBodies then
        local lw = love.graphics.getLineWidth()
        love.graphics.setLineWidth(6)
        love.graphics.setColor(1, 0, 1) -- Red outline for selection
        for _, thing in ipairs(uiState.selectedBodies) do
            --local fixtures = body:getFixtures()
            local body = thing.body
            for _, fixture in ipairs(body:getFixtures()) do
                --for fixture in pairs(fixtures) do
                local shape = fixture:getShape()
                love.graphics.push()
                love.graphics.translate(body:getX(), body:getY())
                love.graphics.rotate(body:getAngle())
                if shape:typeOf("CircleShape") then
                    love.graphics.circle("line", 0, 0, shape:getRadius())
                elseif shape:typeOf("PolygonShape") then
                    local points = { shape:getPoints() }
                    love.graphics.polygon("line", points)
                elseif shape:typeOf("EdgeShape") then
                    local x1, y1, x2, y2 = shape:getPoints()
                    love.graphics.line(x1, y1, x2, y2)
                end
                love.graphics.pop()
            end
        end
        love.graphics.setLineWidth(lw)
        love.graphics.setColor(1, 1, 1) -- Reset color
    end

    -- draw temp poly when changing vertices
    if uiState.polyTempVerts then
        local verts = mathutil.getLocalVerticesForCustomSelected(uiState.polyTempVerts,
            uiState.selectedObj, uiState.polyCentroid.x, uiState.polyCentroid.y)
        love.graphics.setColor(1, 0, 0)
        love.graphics.polygon('line', verts)
        love.graphics.setColor(1, 1, 1) -- Rese
    end

    cam:pop()

    if uiState.startSelection then
        selectrect.draw(uiState.startSelection)
    end

    drawUI()

    if uiState.maybeHideSelectedPanel then
        if not (ui.activeElementID or ui.focusedTextInputID) then
            uiState.selectedObj = nil
            uiState.selectedJoint = nil
        end
        uiState.maybeHideSelectedPanel = false
        uiState.polyTempVerts = nil
        uiState.polyLockedVerts = true
    end

    if FIXED_TIMESTEP then
        love.graphics.print('f' .. string.format("%02d", 1 / TICKRATE), w - 80, 10)
    else
        love.graphics.print(string.format("%03d", love.timer.getFPS()), w - 80, 10)
    end
end

function love.wheelmoved(dx, dy)
    local newScale = cam.scale * (1 + dy / 10)
    if newScale > 0.01 and newScale < 50 then
        cam:scaleToPoint(1 + dy / 10)
    end
end

function love.mousemoved(x, y, dx, dy)
    if uiState.polyDragIdx and uiState.polyDragIdx > 0 then
        local index = uiState.polyDragIdx
        local obj = uiState.selectedObj
        local angle = obj.body:getAngle()
        local dx2, dy2 = mathutil.rotatePoint(dx, dy, 0, 0, -angle)
        dx2 = dx2 / cam.scale
        dy2 = dy2 / cam.scale
        uiState.polyTempVerts[index] = uiState.polyTempVerts[index] + dx2
        uiState.polyTempVerts[index + 1] = uiState.polyTempVerts[index + 1] + dy2
    elseif uiState.capturingPoly then
        local wx, wy = cam:getWorldCoordinates(x, y)
        -- Check if the distance from the last point is greater than minPointDistance
        local addPoint = false
        if not uiState.lastPolyPt then
            addPoint = true
        else
            local lastX, lastY = uiState.lastPolyPt.x, uiState.lastPolyPt.y
            local distSq = (wx - lastX) ^ 2 + (wy - lastY) ^ 2
            if distSq >= (uiState.minPointDistance / cam.scale) ^ 2 then
                addPoint = true
            end
        end
        if addPoint then
            --table.insert(uiState.polygonVertices, { x = wx, y = wy })
            table.insert(uiState.polyVerts, wx)
            table.insert(uiState.polyVerts, wy)
            uiState.lastPolyPt = { x = wx, y = wy }
        end
    elseif love.mouse.isDown(3) then
        local tx, ty = cam:getTranslation()
        cam:setTranslation(tx - dx / cam.scale, ty - dy / cam.scale)
    end
end

function love.filedropped(file)
    local name = file:getFilename()
    if string.find(name, '.playtime.json') then
        file:open("r")
        local data = file:read()
        uiState.selectedJoint = nil
        uiState.selectedObj = nil
        io.load(data, world)
        file:close()
    end
    if string.find(name, '.playtime.lua') then
        file:open("r")
        local data = file:read()

        script.setEnv({ bodies = registry.bodies, joints = registry.joints, world = world, worldState = worldState })
        sceneScript = script.loadScript(data, name)()
        -- print(world)
        if sceneScript and sceneScript.onStart then
            sceneScript.onStart()
        end
        -- print(world)
        file:close()
    end
end

function love.textinput(t)
    ui.handleTextInput(t)
end

local function maybeUpdateCustomPolygonVertices()
    if not utils.tablesEqualNumbers(uiState.polyTempVerts, uiState.selectedObj.vertices) then
        local nx, ny = mathutil.computeCentroid(uiState.polyTempVerts)
        local ox, oy = mathutil.computeCentroid(uiState.selectedObj.vertices)
        local dx = nx - ox
        local dy = ny - oy
        local body = uiState.selectedObj.body
        local oldX, oldY = body:getPosition()
        body:setPosition(oldX + dx, oldY + dy)
        uiState.selectedObj = objectManager.recreateThingFromBody(body,
            { optionalVertices = uiState.polyTempVerts })

        uiState.polyTempVerts = utils.shallowCopy(uiState.selectedObj.vertices)
        -- uiState.selectedObj.vertices = uiState.polyTempVerts
        uiState.polyCentroid = { x = nx, y = ny }
    end
end

local function insertCustomPolygonVertex(x, y)
    local obj = uiState.selectedObj
    local offx, offy = obj.body:getPosition()
    local px, py = mathutil.worldToLocal(x - offx, y - offy, obj.body:getAngle(), uiState.polyCentroid.x,
        uiState.polyCentroid.y)
    -- Find the closest edge index
    local insertAfterVertexIndex = mathutil.findClosestEdge(uiState.polyTempVerts, px, py)
    mathutil.insertValuesAt(uiState.polyTempVerts, insertAfterVertexIndex * 2 + 1, px, py)
end

-- Function to remove a custom polygon vertex based on mouse click
local function removeCustomPolygonVertex(x, y)
    -- Step 1: Convert world coordinates to local coordinates

    local obj = uiState.selectedObj

    local offx, offy = obj.body:getPosition()
    local px, py = mathutil.worldToLocal(x, y, obj.body:getAngle(),
        uiState.polyCentroid.x, uiState.polyCentroid.y)

    -- Step 2: Find the closest vertex index
    local closestVertexIndex = mathutil.findClosestVertex(uiState.polyTempVerts, px, py)

    if closestVertexIndex then
        -- Optional: Define a maximum allowable distance to consider for deletion
        local maxDeletionDistanceSq = 100 -- Adjust as needed (e.g., 10 units squared)
        local vx = uiState.polyTempVerts[(closestVertexIndex - 1) * 2 + 1]
        local vy = uiState.polyTempVerts[(closestVertexIndex - 1) * 2 + 2]
        local dx = px - vx
        local dy = py - vy
        local distSq = dx * dx + dy * dy

        if distSq <= maxDeletionDistanceSq then
            -- Step 3: Remove the vertex from the vertex list

            -- Step 4: Ensure the polygon has a minimum number of vertices (e.g., 3)
            if #uiState.polyTempVerts <= 6 then
                print("Cannot delete vertex: A polygon must have at least three vertices.")
                -- Optionally, you can restore the removed vertex or prevent deletion
                return
            end
            mathutil.removeVertexAt(uiState.polyTempVerts, closestVertexIndex)
            maybeUpdateCustomPolygonVertices()

            -- Debugging Output
            print(string.format("Removed vertex at local coordinates: (%.2f, %.2f)", vx, vy))
        else
            print("No vertex close enough to delete.")
        end
    else
        print("No vertex found to delete.")
    end
end

function love.keypressed(key)
    ui.handleKeyPress(key)
    if key == 'escape' then
        love.event.quit()
    end
    if key == 'space' then
        worldState.paused = not worldState.paused
    end
    if key == 'f5' then
        worldState.paused = true
        uiState.saveDialogOpened = true
    end
    if key == 'i' and uiState.polyTempVerts then
        -- figure out where my mousecursor is, between what nodes?
        local mx, my = love.mouse.getPosition()
        local wx, wy = cam:getWorldCoordinates(mx, my)
        insertCustomPolygonVertex(wx, wy)
        maybeUpdateCustomPolygonVertices()
    end
    if key == 'd' and uiState.polyTempVerts then
        -- Remove a vertex
        local mx, my = love.mouse.getPosition()
        local wx, wy = cam:getWorldCoordinates(mx, my)
        removeCustomPolygonVertex(wx, wy)
    end
end

local function handlePointer(x, y, id, action)
    if action == "pressed" then
        -- Handle press logig
        --   -- this will block interacting on bodies when 'roughly' over the opened panel
        if uiState.saveDialogOpened then return end
        if uiState.selectedJoint or uiState.selectedObj or uiState.selectedBodies or uiState.drawClickPoly then
            local w, h = love.graphics.getDimensions()
            if x > w - 300 then
                return
            end
        end

        local startSelection = love.keyboard.isDown('lshift')
        if (startSelection) then
            uiState.startSelection = { x = x, y = y }
        end

        local cx, cy = cam:getWorldCoordinates(x, y)

        if uiState.polyTempVerts and uiState.selectedObj and uiState.selectedObj.shapeType == 'custom' and uiState.polyLockedVerts == false then
            local verts = mathutil.getLocalVerticesForCustomSelected(uiState.polyTempVerts,
                uiState.selectedObj, uiState.polyCentroid.x, uiState.polyCentroid.y)
            for i = 1, #verts, 2 do
                local vx = verts[i]
                local vy = verts[i + 1]
                local dist = math.sqrt((cx - vx) ^ 2 + (cy - vy) ^ 2)
                if dist < 10 then
                    uiState.polyDragIdx = i

                    return
                else
                    uiState.polyDragIdx = 0
                end
            end
        end

        if (uiState.drawClickPoly) then
            table.insert(uiState.polyVerts, cx)
            table.insert(uiState.polyVerts, cy)
        end
        if (uiState.setOffsetAFunc) then
            uiState.selectedJoint = uiState.setOffsetAFunc(cx, cy)
            uiState.setOffsetAFunc = nil
        end
        if (uiState.setOffsetBFunc) then
            uiState.selectedJoint = uiState.setOffsetBFunc(cx, cy)
            uiState.setOffsetBFunc = nil
        end

        local onPressedParams = {
            pointerForceFunc = function(fixture)
                return worldState.mouseForce
            end,
            damp = worldState.mouseDamping
        }

        local _, hitted = phys.handlePointerPressed(cx, cy, id, onPressedParams, not worldState.paused)

        if (uiState.selectedBodies and #hitted == 0) then
            uiState.selectedBodies = nil
        end

        if #hitted > 0 then
            local ud = hitted[1]:getBody():getUserData()
            if ud and ud.thing then
                uiState.selectedObj = ud.thing
            end
            if uiState.jointCreationMode then
                if uiState.jointCreationMode.body1 == nil then
                    uiState.jointCreationMode.body1 = uiState.selectedObj.body
                elseif uiState.jointCreationMode.body2 == nil then
                    if (uiState.selectedObj.body ~= uiState.jointCreationMode.body1) then
                        uiState.jointCreationMode.body2 = uiState.selectedObj.body
                    end
                end
            end

            if (worldState.paused) then
                -- local ud = uiState.currentlySelectedObject:getBody():getUserData()
                uiState.draggingObj = uiState.selectedObj
                if uiState.selectedObj then
                    local offx, offy = uiState.selectedObj.body:getLocalPoint(cx, cy)
                    uiState.offsetDragging = { -offx, -offy }
                end
            end
        else
            uiState.maybeHideSelectedPanel = true
        end
    elseif action == "released" then
        -- Handle release logic
        phys.handlePointerReleased(x, y, id)
        if uiState.draggingObj then
            uiState.draggingObj.body:setAwake(true)
            uiState.selectedObj = uiState.draggingObj
            uiState.draggingObj = nil
        end

        if uiState.drawFreePoly then
            finalizePolygon()
        end

        if uiState.polyDragIdx > 0 then
            uiState.polyDragIdx = 0
            maybeUpdateCustomPolygonVertices()
        end

        if (uiState.startSelection) then
            local tlx = math.min(uiState.startSelection.x, x)
            local tly = math.min(uiState.startSelection.y, y)
            local brx = math.max(uiState.startSelection.x, x)
            local bry = math.max(uiState.startSelection.y, y)
            local tlxw, tlyw = cam:getWorldCoordinates(tlx, tly)
            local brxw, bryw = cam:getWorldCoordinates(brx, bry)
            local selected = selectrect.selectWithin(world,
                { x = tlxw, y = tlyw, width = brxw - tlxw, height = bryw - tlyw })

            uiState.selectedBodies = selected

            uiState.startSelection = nil
        end
    end
end

function love.mousepressed(x, y, button, istouch)
    if not istouch and button == 1 then
        if uiState.drawFreePoly then
            -- Start capturing mouse movement
            uiState.capturingPoly = true
            uiState.polyVerts = {}
            uiState.lastPolyPt = nil
        else
            handlePointer(x, y, 'mouse', 'pressed')
        end
    end

    if playWithSoftbodies and button == 2 then
        local cx, cy = cam:getWorldCoordinates(x, y)
        local b = blob.softbody(world, cx, cy, 102, 2, 4)
        b:setFrequency(1)
        b:setDamping(0.1)
        b:setFriction(1)

        table.insert(softbodies, b)
    end
end

function love.touchpressed(id, x, y, dx, dy, pressure)
    handlePointer(x, y, id, 'pressed')
end

function love.mousereleased(x, y, button, istouch)
    if not istouch then
        handlePointer(x, y, 'mouse', 'released')
    end
end

function love.touchreleased(id, x, y, dx, dy, pressure)
    handlePointer(x, y, id, 'released')
end

if FIXED_TIMESTEP then
    function love.run()
        if love.math then
            love.math.setRandomSeed(os.time())
        end

        if love.load then love.load(arg) end

        local previous = love.timer.getTime()
        local lag = 0.0
        while true do
            local current = love.timer.getTime()
            local elapsed = current - previous
            previous = current
            lag = lag + elapsed

            if love.event then
                love.event.pump()
                for name, a, b, c, d, e, f in love.event.poll() do
                    if name == "quit" then
                        if not love.quit or not love.quit() then
                            return a
                        end
                    end
                    love.handlers[name](a, b, c, d, e, f)
                end
            end

            while lag >= TICKRATE do
                if love.update then love.update(TICKRATE) end
                lag = lag - TICKRATE
            end

            if love.graphics and love.graphics.isActive() then
                love.graphics.clear(love.graphics.getBackgroundColor())
                love.graphics.origin()
                if love.draw then love.draw(lag / TICKRATE) end
                love.graphics.present()
            end
        end
    end
end
local lib = {}

local function getBodyColor(body)
    if body:getType() == 'kinematic' then
        return { 1, 0, 0, 1 } --palette[colors.peach]
    end
    if body:getType() == 'dynamic' then
        return { 0, 1, 0, 1 } --palette[colors.blue]
    end
    if body:getType() == 'static' then
        return { 1, 1, 0, 1 } --palette[colors.green]
    end
end

function lib.drawWorld(world)
    local r, g, b, a = love.graphics.getColor()
    local alpha = .8
    love.graphics.setLineJoin("none")
    love.graphics.setColor(0, 0, 0, alpha)
    local bodies = world:getBodies()
    -- love.graphics.setLineWidth(1)
    for _, body in ipairs(bodies) do
        local fixtures = body:getFixtures()

        for _, fixture in ipairs(fixtures) do
            --if fixture:getUserData() then
            --     print(inspect(fixture:getUserData()))
            --end
            if fixture:getShape():type() == 'PolygonShape' then
                local color = getBodyColor(body)
                love.graphics.setColor(color[1], color[2], color[3], alpha)
                if (fixture:getUserData()) then
                    if fixture:getUserData().bodyType == "connector" then
                        love.graphics.setColor(1, 0, 0, alpha)
                    end
                end
                love.graphics.polygon("fill", body:getWorldPoints(fixture:getShape():getPoints()))
                love.graphics.setColor(1, 1, 1, alpha)
                if (fixture:getUserData()) then
                    if fixture:getUserData().bodyType == "connector" then
                        love.graphics.setColor(1, 0, 0, alpha)
                    end
                    --  print(inspect(fixture:getUserData() ))
                end
                love.graphics.polygon('line', body:getWorldPoints(fixture:getShape():getPoints()))
            elseif fixture:getShape():type() == 'EdgeShape' or fixture:getShape():type() == 'ChainShape' then
                love.graphics.setColor(1, 1, 1, alpha)
                local points = { body:getWorldPoints(fixture:getShape():getPoints()) }
                for i = 1, #points, 2 do
                    if i < #points - 2 then love.graphics.line(points[i], points[i + 1], points[i + 2], points[i + 3]) end
                end
            elseif fixture:getShape():type() == 'CircleShape' then
                local body_x, body_y = body:getPosition()
                local shape_x, shape_y = fixture:getShape():getPoint()
                local r = fixture:getShape():getRadius()
                local color = getBodyColor(body)
                love.graphics.setColor(color[1], color[2], color[3], alpha)
                love.graphics.circle('fill', body_x + shape_x, body_y + shape_y, r, 360)
                love.graphics.setColor(1, 1, 1, alpha)
                love.graphics.circle('line', body_x + shape_x, body_y + shape_y, r, 360)
            end
        end
    end
    love.graphics.setColor(255, 255, 255, alpha)
    -- Joint debug

    local joints = world:getJoints()
    for _, joint in ipairs(joints) do
        local x1, y1, x2, y2 = joint:getAnchors()

        if (x1 and y1 and x2 and y2) then
            love.graphics.setColor(1, 1, 1, alpha)
            love.graphics.line(x1, y1, x2, y2)
        end
        love.graphics.setColor(1, 0, 0, alpha)
        love.graphics.setLineJoin("miter")
        if x1 and y1 then love.graphics.circle('line', x1, y1, 4) end
        if x2 and y2 then love.graphics.circle('line', x2, y2, 4) end
        love.graphics.setLineJoin("none")

        local jointType = joint:getType()
        if jointType == 'pulley' then
            local gx1, gy1, gx2, gy2 = joint:getGroundAnchors()
            love.graphics.setColor(1, 1, 0, alpha)
            love.graphics.line(x1, y1, gx1, gy1)
            love.graphics.line(x2, y2, gx2, gy2)
            love.graphics.line(gx1, gy1, gx2, gy2)
        end
        if jointType == 'prismatic' then
            local x, y = joint:getAnchors()
            local ax, ay = joint:getAxis()
            local length = 50
            love.graphics.setColor(1, 0.5, 0) -- Orange
            love.graphics.line(x, y, x + ax * length, y + ay * length)
            if joint:areLimitsEnabled() then
                local lower, upper = joint:getLimits()
                love.graphics.setColor(1, 1, 0) -- Yellow
                love.graphics.line(x + ax * lower, y + ay * lower, x + ax * lower + ax * 10, y + ay * lower + ay * 10)
                love.graphics.line(x + ax * upper, y + ay * upper, x + ax * upper + ax * 10, y + ay * upper + ay * 10)
            end
            love.graphics.setColor(1, 1, 1) -- Reset
        end
        if jointType == 'revolute' then
            if joint:areLimitsEnabled() then
                local lower = joint:getLowerLimit()
                local upper = joint:getUpperLimit()

                local bodyA, bodyB = joint:getBodies()
                local b1A = bodyA:getAngle()

                love.graphics.setColor(1, 1, 1, alpha)
                love.graphics.setLineJoin("miter")
                love.graphics.arc('line', x1, y1, 15, math.pi / 2 + b1A + lower, math.pi / 2 + b1A + upper)
                love.graphics.setLineJoin("none")


                local b1B = bodyB:getAngle()

                local angleBetween = b1A - b1B

                local endX, endY = getEndpoint(x1, y1, (b1B + math.pi / 2), 15)

                love.graphics.setColor(0.5, 0.5, 0.5, alpha)
                love.graphics.line(x1, y1, endX, endY)
            end
        end
        if jointType == 'wheel' then
            -- Draw wheel joint axis
            local axisX, axisY = joint:getAxis()
            if x1 and y1 and axisX and axisY then
                local axisLength = 50                   -- Scale factor for visualizing the axis
                love.graphics.setColor(0, .5, 0, alpha) -- Green for axis
                love.graphics.line(x1, y1, x1 + axisX * axisLength, y1 + axisY * axisLength)
                love.graphics.setColor(1, 1, 1, alpha)
            end
        end
    end
    love.graphics.setLineJoin("miter")
    love.graphics.setColor(r, g, b, a)
    --   love.graphics.setLineWidth(1)
end

return lib
--io.lua
local lib = {}

local inspect = require 'vendor.inspect'
local json = require 'vendor.dkjson'
local uuid = require 'src.uuid'
local registry = require 'src.registry'
local shapes = require 'src.shapes'
local jointHandlers = require 'src.joint-handlers'
local mathutils = require 'src.math-utils'
local utils = require 'src.utils'


function lib.load(data, world)
    local jsonData, pos, err = json.decode(data, 1, nil)
    if err then
        print("Error decoding JSON:", err)
        return
    end

    -- Verify version
    if jsonData then
        if jsonData.version ~= "1.0" then
            print("Unsupported save version:", jsonData.version)
            return
        end
    else
        print('failed loading json')
        return
    end
    -- Clear existing world

    local idMap = {}
    local function getNewId(oldId)
        if idMap[oldId] == nil then
            idMap[oldId] = uuid.generateID()
        end
        return idMap[oldId]
    end

    if true then
        for _, body in pairs(world:getBodies()) do
            body:destroy()
        end
        registry.reset()
    end
    -- Iterate through saved bodies and recreate them
    for _, bodyData in ipairs(jsonData.bodies) do
        -- Create a new body
        local body = love.physics.newBody(world, bodyData.position[1], bodyData.position[2], bodyData.bodyType)
        body:setAngle(bodyData.angle)
        body:setLinearVelocity(bodyData.linearVelocity[1], bodyData.linearVelocity[2])
        body:setAngularVelocity(bodyData.angularVelocity)
        body:setFixedRotation(bodyData.fixedRotation)

        local shared = bodyData.sharedFixtureData
        -- Iterate through fixtures and recreate shapes
        for _, fixtureData in ipairs(bodyData.fixtures) do
            local shape
            if shared.shapeType == "circle" then
                shape = love.physics.newCircleShape(fixtureData.radius)
            elseif shared.shapeType == "polygon" then
                local points = {}
                -- for _, point in ipairs(fixtureData.points) do
                --     table.insert(points, point.x)
                --     table.insert(points, point.y)
                -- end
                for _, point in ipairs(fixtureData.points) do
                    table.insert(points, point)
                end
                shape = love.physics.newPolygonShape(unpack(points))
                -- elseif fixtureData.shapeType == "edge" then
                --     local x1 = fixtureData.points[1].x
                --     local y1 = fixtureData.points[1].y
                --     local x2 = fixtureData.points[2].x
                --     local y2 = fixtureData.points[2].y
                --     shape = love.physics.newEdgeShape(x1, y1, x2, y2)
            else
                print("Unsupported shape type:", fixtureData.shapeType)
            end

            if shape then
                local fixture = love.physics.newFixture(body, shape, shared.density)
                fixture:setFriction(shared.friction)
                fixture:setRestitution(shared.restitution)
            end
        end

        -- Recreate the 'thing' table
        local thing = {
            id = getNewId(bodyData.id),
            label = bodyData.label,
            shapeType = bodyData.shapeType,
            radius = bodyData.radius,
            width = bodyData.width,
            height = bodyData.height,
            body = body,
            vertices = bodyData.vertices,
            --  shape = body:getFixtures()[1]:getShape(), -- Assuming one fixture per body
            fixture = body:getFixtures()[1], -- this is used in clone.
        }

        -- Assign the 'thing' to the body's user data
        body:setUserData({ thing = thing })
        registry.registerBody(thing.id, body)
    end

    -- Iterate through saved joints and recreate them
    for _, jointData in ipairs(jsonData.joints) do
        local bodyA = registry.getBodyByID(getNewId(jointData.bodyA))
        local bodyB = registry.getBodyByID(getNewId(jointData.bodyB))

        if bodyA and bodyB then
            local joint
            local anchorA = jointData.anchorA
            local anchorB = jointData.anchorB
            local collideConnected = jointData.collideConnected


            if jointData.type == "distance" then
                joint = love.physics.newDistanceJoint(
                    bodyA, bodyB,
                    anchorA[1], anchorA[2],
                    anchorB[1], anchorB[2],
                    collideConnected
                )
                joint:setLength(jointData.properties.length)
                joint:setFrequency(jointData.properties.frequency)
                joint:setDampingRatio(jointData.properties.dampingRatio)
            elseif jointData.type == "revolute" then
                joint = love.physics.newRevoluteJoint(
                    bodyA, bodyB,
                    anchorA[1], anchorA[2],
                    collideConnected
                )
                joint:setMotorEnabled(jointData.properties.motorEnabled)
                if jointData.properties.motorEnabled then
                    joint:setMotorSpeed(jointData.properties.motorSpeed)
                    joint:setMaxMotorTorque(jointData.properties.maxMotorTorque)
                end
                joint:setLimitsEnabled(jointData.properties.limitsEnabled)
                if jointData.properties.limitsEnabled then
                    joint:setLimits(jointData.properties.lowerLimit, jointData.properties.upperLimit)
                end
            elseif jointData.type == "rope" then
                joint = love.physics.newRopeJoint(
                    bodyA, bodyB,
                    anchorA[1], anchorA[2],
                    anchorB[1], anchorB[2],
                    jointData.properties.maxLength
                )
            elseif jointData.type == "weld" then
                joint = love.physics.newWeldJoint(
                    bodyA, bodyB,
                    anchorA[1], anchorA[2],
                    collideConnected
                )
                joint:setFrequency(jointData.properties.frequency)
                joint:setDampingRatio(jointData.properties.dampingRatio)
            elseif jointData.type == "prismatic" then
                joint = love.physics.newPrismaticJoint(
                    bodyA, bodyB,
                    anchorA[1], anchorA[2],
                    jointData.properties.axis.x, jointData.properties.axis.y,
                    collideConnected
                )
                joint:setMotorEnabled(jointData.properties.motorEnabled)
                if jointData.properties.motorEnabled then
                    joint:setMotorSpeed(jointData.properties.motorSpeed)
                    joint:setMaxMotorForce(jointData.properties.maxMotorForce)
                end
                joint:setLimitsEnabled(jointData.properties.limitsEnabled)
                if jointData.properties.limitsEnabled then
                    joint:setLimits(jointData.properties.lowerLimit, jointData.properties.upperLimit)
                end
            elseif jointData.type == "pulley" then
                joint = love.physics.newPulleyJoint(
                    bodyA, bodyB,
                    jointData.properties.groundAnchor1.x, jointData.properties.groundAnchor1.y,
                    jointData.properties.groundAnchor2.x, jointData.properties.groundAnchor2.y,
                    anchorA[1], anchorA[2],
                    anchorB[1], anchorB[2],
                    jointData.properties.ratio,
                    collideConnected
                )
            elseif jointData.type == "wheel" then
                joint = love.physics.newWheelJoint(
                    bodyA, bodyB,
                    anchorA[1], anchorA[2],
                    jointData.properties.axis.x, jointData.properties.axis.y,
                    collideConnected
                )
                joint:setSpringFrequency(jointData.properties.springFrequency)
                joint:setSpringDampingRatio(jointData.properties.springDampingRatio)

                joint:setMotorEnabled(jointData.properties.motorEnabled)

                if jointData.properties.motorEnabled then
                    joint:setMotorSpeed(jointData.properties.motorSpeed)
                    joint:setMaxMotorTorque(jointData.properties.maxMotorTorque)
                end
            elseif jointData.type == "motor" then
                joint = love.physics.newMotorJoint(
                    bodyA, bodyB,
                    jointData.properties.correctionFactor,
                    collideConnected
                )
                joint:setAngularOffset(jointData.properties.angularOffset)
                joint:setLinearOffset(jointData.properties.linearOffsetX, jointData.properties.linearOffsetY)
                joint:setMaxForce(jointData.properties.maxForce)
                joint:setMaxTorque(jointData.properties.maxTorque)
            elseif jointData.type == "friction" then
                joint = love.physics.newFrictionJoint(
                    bodyA, bodyB,
                    anchorA[1], anchorA[2],
                    collideConnected
                )
                joint:setMaxForce(jointData.properties.maxForce)
                joint:setMaxTorque(jointData.properties.maxTorque)
            else
                -- Handle unsupported joint types
                print("Unsupported joint type during load:", jointData.type)
            end

            if joint then
                -- Assign the joint ID
                -- joint:setUserData({ id = jointData.id })


                local fxa, fya = mathutils.rotatePoint(anchorA[1] - bodyA:getX(), anchorA[2] - bodyA:getY(), 0, 0,
                    -bodyA:getAngle())
                local fxb, fyb = mathutils.rotatePoint(anchorB[1] - bodyB:getX(), anchorB[2] - bodyB:getY(), 0, 0,
                    -bodyB:getAngle())
                joint:setUserData({
                    id = getNewId(jointData.id),
                    offsetA = { x = fxa, y = fya },
                    offsetB = { x = fxb, y = fyb }
                })


                -- Register the joint in the registry
                registry.registerJoint(jointData.id, joint)
            end
        else
            print("Failed to find bodies for joint:", jointData.id)
        end
    end

    print("World successfully loaded")
end

function lib.save(world, worldState, filename)
    local saveData = {
        version = "1.0", -- Versioning for future compatibility
        bodies = {},
        joints = {}
    }
    for _, body in pairs(world:getBodies()) do
        local userData = body:getUserData()
        local thing = userData and userData.thing

        if thing then
            local lvx, lvy = body:getLinearVelocity()
            local bodyData = {
                id = thing.id, -- Unique identifier
                label = utils.sanitizeString(thing.label),
                shapeType = thing.shapeType,
                radius = thing.radius,
                width = thing.width,
                height = thing.height,
                vertices = thing.shapeType == 'custom' and thing.vertices,
                bodyType = body:getType(), -- 'dynamic', 'kinematic', or 'static'
                position = { utils.round_to_decimals(body:getX(), 4), utils.round_to_decimals(body:getY(), 4) },
                angle = utils.round_to_decimals(body:getAngle(), 4),
                linearVelocity = { lvx, lvy },
                angularVelocity = utils.round_to_decimals(body:getAngularVelocity(), 4),
                fixedRotation = body:isFixedRotation(),
                fixtures = {},
                sharedFixtureData = {}
            }
            -- Iterate through all fixtures of the body

            -- to save data i am assuming all fixtures are the same type and have the same settings.
            local bodyFixtures = body:getFixtures()
            if #bodyFixtures >= 1 then
                if #bodyFixtures >= 1 then
                    local first = bodyFixtures[1]
                    bodyData.sharedFixtureData.density = utils.round_to_decimals(first:getDensity(), 4)
                    bodyData.sharedFixtureData.friction = utils.round_to_decimals(first:getFriction(), 4)
                    bodyData.sharedFixtureData.restitution = utils.round_to_decimals(first:getRestitution(), 4)
                    local shape = first:getShape()
                    if shape:typeOf("CircleShape") then
                        bodyData.sharedFixtureData.shapeType = 'circle'
                    elseif shape:typeOf("PolygonShape") then
                        bodyData.sharedFixtureData.shapeType = 'polygon'
                    end
                end
            end

            for _, fixture in ipairs(body:getFixtures()) do
                local shape = fixture:getShape()

                local fixtureData = {}
                if shape:typeOf("CircleShape") then
                    --fixtureData.shapeType = "circle"
                    fixtureData.radius = shape:getRadius()
                elseif shape:typeOf("PolygonShape") then
                    local result = {}
                    local points = { shape:getPoints() }
                    for i = 1, #points do
                        table.insert(result, utils.round_to_decimals(points[i], 3))
                    end
                    fixtureData.points = result
                    -- elseif shape:typeOf("EdgeShape") then
                    --     fixtureData.shapeType = "edge"
                    --     local x1, y1, x2, y2 = shape:getPoints()
                    --     fixtureData.points = { { x = x1, y = y1 }, { x = x2, y = y2 } }
                else
                    -- Handle other shape types if any
                    fixtureData.shapeType = "unknown"
                end

                table.insert(bodyData.fixtures, fixtureData)
            end

            table.insert(saveData.bodies, bodyData)
        end
    end

    -- Iterate through all joints in the world
    for _, joint in pairs(world:getJoints()) do
        local jointUserData = joint:getUserData()
        local jointID = jointUserData and jointUserData.id

        if not jointID then
            print('what is up with this joint?')
        end
        -- Get connected bodies
        local bodyA, bodyB = joint:getBodies()

        local thingA = bodyA:getUserData() and bodyA:getUserData().thing
        local thingB = bodyB:getUserData() and bodyB:getUserData().thing

        if thingA and thingB then
            local x1, y1, x2, y2 = joint:getAnchors()
            local jointData = {
                id = jointID,
                type = joint:getType(),
                bodyA = thingA.id,
                bodyB = thingB.id,
                anchorA = { utils.round_to_decimals(x1, 3), utils.round_to_decimals(y1, 3) },
                anchorB = { utils.round_to_decimals(x2, 3), utils.round_to_decimals(y2, 3) },
                collideConnected = joint:getCollideConnected(),
                properties = {}
            }

            -- Extract joint-specific properties
            if joint:getType() == "distance" then
                jointData.properties.length = joint:getLength()
                jointData.properties.frequency = joint:getFrequency()
                jointData.properties.dampingRatio = joint:getDampingRatio()
            elseif joint:getType() == 'rope' then
                jointData.properties.maxLength = joint:getMaxLength()
            elseif joint:getType() == "revolute" then
                jointData.properties.motorEnabled = joint:isMotorEnabled()
                if jointData.properties.motorEnabled then
                    jointData.properties.motorSpeed = joint:getMotorSpeed()
                    jointData.properties.maxMotorTorque = joint:getMaxMotorTorque()
                end
                jointData.properties.limitsEnabled = joint:areLimitsEnabled()
                if jointData.properties.limitsEnabled then
                    jointData.properties.lowerLimit = joint:getLowerLimit()
                    jointData.properties.upperLimit = joint:getUpperLimit()
                end
            elseif joint:getType() == "weld" then
                jointData.properties.frequency = joint:getFrequency()
                jointData.properties.dampingRatio = joint:getDampingRatio()
            elseif joint:getType() == "prismatic" then
                local axisx, axisy = joint:getAxis()
                jointData.properties.axis = { x = axisx, y = axisy }
                jointData.properties.motorEnabled = joint:isMotorEnabled()
                if jointData.properties.motorEnabled then
                    jointData.properties.motorSpeed = joint:getMotorSpeed()
                    jointData.properties.maxMotorForce = joint:getMaxMotorForce()
                end
                jointData.properties.limitsEnabled = joint:areLimitsEnabled()
                if jointData.properties.limitsEnabled then
                    jointData.properties.lowerLimit = joint:getLowerLimit()
                    jointData.properties.upperLimit = joint:getUpperLimit()
                end
            elseif joint:getType() == "pulley" then
                local a1x, a1y, a2x, a2y = joint:getGroundAnchors()
                jointData.properties.groundAnchor1 = { x = a1x, y = a1y }
                jointData.properties.groundAnchor2 = { x = a2x, y = a2y }
                jointData.properties.ratio = joint:getRatio()
            elseif joint:getType() == "wheel" then
                jointData.properties.motorEnabled = joint:isMotorEnabled()
                if jointData.properties.motorEnabled then
                    jointData.properties.motorSpeed = joint:getMotorSpeed()
                    jointData.properties.maxMotorTorque = joint:getMaxMotorTorque()
                end
                local axisx, axisy = joint:getAxis()
                jointData.properties.axis = { x = axisx, y = axisy }
                jointData.properties.springFrequency = joint:getSpringFrequency()
                jointData.properties.springDampingRatio = joint:getSpringDampingRatio()
            elseif joint:getType() == "motor" then
                jointData.properties.correctionFactor = joint:getCorrectionFactor()
                jointData.properties.angularOffset = joint:getAngularOffset()
                jointData.properties.linearOffsetX, jointData.properties.linearOffsetY = joint:getLinearOffset()
                jointData.properties.maxForce = joint:getMaxForce()
                jointData.properties.maxTorque = joint:getMaxTorque()
            elseif joint:getType() == "friction" then
                jointData.properties.maxForce = joint:getMaxForce()
                jointData.properties.maxTorque = joint:getMaxTorque()
            else
                -- Handle unsupported joint types
                print("Unsupported joint type during save:", joint:getType())
            end

            table.insert(saveData.joints, jointData)
        else
            print("Failed to find bodies for joint:", jointID)
        end
    end
    -- Serialize the data to JSON
    local jsonData = json.encode(saveData, { indent = true })

    -- Write the JSON data to a file
    local success, message = love.filesystem.write(filename .. '.playtime.json', jsonData)
    if success then
        print("World successfully saved to " .. filename)
        print("file://" .. love.filesystem.getSaveDirectory())
    else
        print("Failed to save world:", message)
    end

    love.system.openURL("file://" .. love.filesystem.getSaveDirectory())
end

function lib.cloneSelection(selectedBodies)
    -- Mapping from original body IDs to cloned body instances
    local clonedBodiesMap = {}

    -- Step 1: Clone Bodies
    for _, originals in ipairs(selectedBodies) do
        local originalBody = originals.body
        local userData     = originalBody:getUserData()
        if userData and userData.thing then
            local originalThing = userData.thing

            -- Generate a new unique ID for the cloned body
            local newID = uuid.generateID()

            -- Clone body properties
            local newBody = love.physics.newBody(world, originalBody:getX() + 50, originalBody:getY() + 50,
                originalBody:getType())
            newBody:setAngle(originalBody:getAngle())
            newBody:setLinearVelocity(originalBody:getLinearVelocity())
            newBody:setAngularVelocity(originalBody:getAngularVelocity())
            newBody:setFixedRotation(originalBody:isFixedRotation())
            newBody:setSleepingAllowed(originalBody:isSleepingAllowed())

            -- Clone shape

            local newShapeList, newVertices = shapes.createShape(originalThing.shapeType, originalThing.radius,
                originalThing.width,
                originalThing.height, originalThing.vertices)


            local oldFixtures = originalBody:getFixtures()
            --print(#oldFixtures, #newShapeList, inspect(originalThing.vertices))

            for i = 1, #oldFixtures do
                local oldF = oldFixtures[i]
                local newFixture = love.physics.newFixture(newBody, newShapeList[i], oldF:getDensity())
                newFixture:setRestitution(oldF:getRestitution())
                newFixture:setFriction(oldF:getFriction())
            end
            -- Clone fixture
            --local newFixture = love.physics.newFixture(newBody, newShape, originalThing.fixture:getDensity())
            --newFixture:setRestitution(originalThing.fixture:getRestitution())
            --newFixture:setFriction(originalThing.fixture:getFriction())

            -- Clone user data
            if (originalThing.vertices) then
                utils.trace('vertex count before and after cloning ', #originalThing.vertices, #newVertices)
            end
            local clonedThing = {
                shapeType = originalThing.shapeType,
                radius = originalThing.radius,
                width = originalThing.width,
                height = originalThing.height,
                label = originalThing.label,
                body = newBody,
                shapes = newShapeList,
                vertices = newVertices,
                id = newID
            }
            newBody:setUserData({ thing = clonedThing })

            -- Register the cloned body
            registry.registerBody(newID, newBody)

            -- Store in the map for joint cloning
            clonedBodiesMap[originalThing.id] = clonedThing
        end
    end

    local doneJoints = {}
    -- Step 2: Clone Joints
    for _, originalThing in ipairs(uiState.selectedBodies) do
        local originalBody = originalThing.body
        local joints = originalBody:getJoints()
        for _, originalJoint in ipairs(joints) do
            local ud = originalJoint:getUserData()
            if ud and ud.id then
                if not doneJoints[ud.id] == true then -- make sure we dont do joints twice..
                    local jointType = originalJoint:getType()
                    local handler = jointHandlers[jointType]
                    doneJoints[ud.id] = true
                    if handler and handler.extract then
                        local jointData = handler.extract(originalJoint)
                        utils.trace(inspect(jointData))
                        -- Determine the original bodies connected by the joint
                        local bodyA, bodyB = originalJoint:getBodies()
                        local clonedBodyA = clonedBodiesMap[bodyA:getUserData().thing.id]
                        local clonedBodyB = clonedBodiesMap[bodyB:getUserData().thing.id]

                        -- If both bodies are cloned, proceed to clone the joint
                        if clonedBodyA and clonedBodyB then
                            local newJointData = {
                                body1 = clonedBodyA.body,
                                body2 = clonedBodyB.body,
                                jointType = jointType,
                                collideConnected = originalJoint:getCollideConnected(),
                                id = uuid.generateID()
                            }

                            -- Include all joint-specific properties
                            for key, value in pairs(jointData) do
                                newJointData[key] = value
                            end
                            --  print(inspect(newJointData))
                            -- Create the new joint
                            local newJoint = handler.create(newJointData,
                                clonedBodyA.body:getX(), clonedBodyA.body:getY(),
                                clonedBodyB.body:getX(), clonedBodyB.body:getY()
                            )

                            print(inspect(newJoint))
                            local ax, ay, bx, by = newJoint:getAnchors()
                            local fxa, fya = mathutils.rotatePoint(ax - clonedBodyA.body:getX(),
                                ay - clonedBodyA.body:getY(), 0, 0,
                                -bodyA:getAngle())
                            local fxb, fyb = mathutils.rotatePoint(bx - clonedBodyB.body:getX(),
                                by - clonedBodyB.body:getY(), 0, 0,
                                -bodyB:getAngle())


                            -- Set user data for the new joint
                            newJoint:setUserData({ id = newJointData.id, offsetA = { x = fxa, y = fya }, offsetB = { x = fxb, y = fyb } })
                            --                             })

                            -- Register the new joint
                            registry.registerJoint(newJointData.id, newJoint)
                        end
                    end
                end
            end
        end
    end

    local result = {}
    for k, v in pairs(clonedBodiesMap) do
        table.insert(result, v)
    end
    return result
    --uiState.selectedBodies = result
end

return lib
-- jointHandlers.lua (Create a separate module for better organization)
local jointHandlers = {}

jointHandlers["distance"] = {
    create = function(data, x1, y1, x2, y2)
        local length = data.length or math.sqrt((x2 - x1) ^ 2 + (y2 - y1) ^ 2)
        local joint = love.physics.newDistanceJoint(data.body1, data.body2, x1, y1, x2, y2, data.collideConnected)
        joint:setLength(length)
        return joint
    end,

    extract = function(joint)
        return {
            length = joint:getLength(),
            frequency = joint:getFrequency(),
            dampingRatio = joint:getDampingRatio(),
        }
    end
}
jointHandlers["weld"] = {
    create = function(data, x1, y1, x2, y2)
        local joint = love.physics.newWeldJoint(data.body1, data.body2, x1, y1, data.collideConnected)
        return joint
    end,
    extract = function(joint)
        return {
            frequency = joint:getFrequency(),
            dampingRatio = joint:getDampingRatio(),
        }
    end
}
jointHandlers["rope"] = {
    create = function(data, x1, y1, x2, y2)
        local maxLength = data.maxLength or math.sqrt((x2 - x1) ^ 2 + (y2 - y1) ^ 2)
        local joint = love.physics.newRopeJoint(data.body1, data.body2, x1, y1, x2, y2, maxLength, data.collideConnected)
        return joint
    end,
    extract = function(joint)
        return {
            maxLength = joint:getMaxLength()
        }
    end
}
jointHandlers["revolute"] = {
    create = function(data, x1, y1, x2, y2)
        local joint = love.physics.newRevoluteJoint(data.body1, data.body2, x1, y1, data.collideConnected)
        return joint
    end,
    extract = function(joint)
        return {
            motorEnabled = joint:isMotorEnabled(),
            motorSpeed = joint:getMotorSpeed(),
            maxMotorTorque = joint:getMaxMotorTorque(),
            limitsEnabled = joint:areLimitsEnabled(),
            lowerLimit = joint:getLowerLimit(),
            upperLimit = joint:getUpperLimit(),
        }
    end
}
jointHandlers["wheel"] = {
    create = function(data, x1, y1, x2, y2)
        local joint = love.physics.newWheelJoint(data.body1, data.body2, x1, y1, data.axisX or 0, data.axisY or 1,
            data.collideConnected)

        if data.springFrequency then
            joint:setSpringFrequency(data.springFrequency)
        end
        if data.springDampingRatio then
            joint:setSpringDampingRatio(data.springDampingRatio)
        end
        return joint
    end,
    extract = function(joint)
        return {
            springFrequency = joint:getSpringFrequency(),
            springDampingRatio = joint:getSpringDampingRatio(),
        }
    end
}
jointHandlers["motor"] = {
    create = function(data, x1, y1, x2, y2)
        local joint = love.physics.newMotorJoint(data.body1, data.body2, data.correctionFactor or .3,
            data.collideConnected)
        return joint
    end,
    extract = function(joint)
        local lox, loy = joint:getLinearOffset()
        return {
            correctionFactor = joint:getCorrectionFactor(),
            angularOffset = joint:getAngularOffset(),
            linearOffsetX = lox,
            linearOffsetY = loy,
            maxForce = joint:getMaxForce(),
            maxTorque = joint:getMaxTorque()
        }
    end
}
jointHandlers["prismatic"] = {
    create = function(data, x1, y1, x2, y2)
        local joint = love.physics.newPrismaticJoint(data.body1, data.body2, x1, y1, data.axisX or 0, data.axisY or 1,
            data.collideConnected)
        joint:setLowerLimit(0)
        joint:setUpperLimit(0)
        return joint
    end,
    extract = function(joint)
        return {
            motorEnabled = joint:isMotorEnabled(),
            motorSpeed = joint:getMotorSpeed(),
            maxMotorForce = joint:getMaxMotorForce(),
            limitsEnabled = joint:areLimitsEnabled(),
            lowerLimit = joint:getLowerLimit(),
            upperLimit = joint:getUpperLimit(),

        }
    end
}
jointHandlers["pulley"] = {
    create = function(data, x1, y1, x2, y2)
        local groundAnchorA = data.groundAnchor1 or { 0, 0 }
        local groundAnchorB = data.groundAnchor2 or { 0, 0 }
        local bodyA_centerX, bodyA_centerY = data.body1:getWorldCenter()
        local bodyB_centerX, bodyB_centerY = data.body2:getWorldCenter()
        local ratio = data.ratio or 1

        local joint = love.physics.newPulleyJoint(
            data.body1, data.body2,
            bodyA_centerX or groundAnchorA[1], groundAnchorA[2],
            bodyB_centerX or groundAnchorB[1], groundAnchorB[2],
            bodyA_centerX, bodyA_centerY,
            bodyB_centerX, bodyB_centerY,
            ratio,
            false
        )
        return joint
    end,
    extract = function(joint)
        local x1, y1, x2, y2 = joint:getGroundAnchors()
        return {
            groundAnchor1 = { x1, y1 },
            groundAnchor2 = { x2, y2 },
            ratio = joint:getRatio()
        }
    end
}
jointHandlers["friction"] = {
    create = function(data, x1, y1, x2, y2)
        -- Create a Friction Joint
        local x, y = data.body1:getPosition()
        local joint = love.physics.newFrictionJoint(data.body1, data.body2, x1, y1, false)

        if data.maxForce then
            joint:setMaxForce(data.maxForce)
        end
        if data.maxTorque then
            joint:setMaxTorque(data.maxTorque)
        end
        return joint
    end,
    extract = function(joint)
        return {
            maxForce = joint:getMaxForce(),
            maxTorque = joint:getMaxTorque(),
        }
    end
}
return jointHandlers
--joints.lua
local ui = require 'src.ui-all'
local lib = {}
local inspect = require 'vendor.inspect'
local uuid = require 'src.uuid'
local jointHandlers = require 'src.joint-handlers'
local registry = require 'src.registry'
local mathutils = require 'src.math-utils'

local offsetHasChangedViaOutside
-- Helper function to create a slider with an associated label
local function createSlider(labelText, x, y, width, min, max, value, callback, changed)
    local newValue = ui.sliderWithInput(labelText, x, y, width, min, max, value, changed)
    if newValue then
        callback(newValue)
    end
    ui.label(x, y, labelText)
    return newValue
end

local function createSliderWithId(id, label, x, y, width, min, max, value, callback, changed)
    local newValue = ui.sliderWithInput(id .. "::" .. label, x, y, width, min, max, value, changed)
    if newValue then
        callback(newValue)
    end
    ui.label(x, y, label)
    return newValue
end
-- Helper function to create a checkbox with an associated label
local function createCheckbox(labelText, x, y, value, callback)
    local changed, newValue = ui.checkbox(x, y, value, labelText)
    if changed then
        callback(newValue)
    end
    return newValue
end


local function getJointId(joint)
    local ud = joint:getUserData()
    if ud then
        return ud.id
    end
    print('THIS IS WRONG WHY THIS JOINT HAS NO ID!!', tostring(joint:getType()))
    return nil
end

local function setJointMetaSetting(joint, settingKey, settingValue)
    -- Get the existing userdata
    local ud = joint:getUserData() or {}

    -- Ensure userdata is a table
    if type(ud) ~= "table" then
        ud = {} -- Initialize as a table if not already
    end

    -- Update or add the specific setting
    ud[settingKey] = settingValue

    -- Set the updated userdata back on the joint
    joint:setUserData(ud)
end

local function getJointMetaSetting(joint, settingKey)
    -- Get the existing userdata
    local ud = joint:getUserData()

    -- Check if userdata exists and is a table
    if type(ud) == "table" then
        return ud[settingKey] -- Return the specific setting
    else
        print('could not find meta settting ' .. settingKey .. ' on joint with type ' .. tostring(joint:getType()))
        return nil -- Return nil if userdata is not a table or doesn't exist
    end
end



function lib.createJoint(data)
    local bodyA = data.body1
    local bodyB = data.body2
    local jointType = data.jointType

    local joint

    local x1, y1 = bodyA:getPosition()
    local x2, y2 = bodyB:getPosition()
    local offsetA = data.offsetA or { x = 0, y = 0 }
    local rx, ry = mathutils.rotatePoint(offsetA.x, offsetA.y, 0, 0, bodyA:getAngle())
    x1, y1 = x1 + rx, y1 + ry

    local offsetB = data.offsetB or { x = 0, y = 0 }
    local rx, ry = mathutils.rotatePoint(offsetB.x, offsetB.y, 0, 0, bodyB:getAngle())
    x2, y2 = x2 + rx, y2 + ry

    local handler = jointHandlers[jointType]

    if handler and handler.create then
        joint = handler.create(data, x1, y1, x2, y2)
    else
        print("Joint type '" .. jointType .. "' is not implemented yet.")
        return
    end

    local setId = data.id or uuid.generateID()
    joint:setUserData({ id = setId })
    setJointMetaSetting(joint, 'offsetA', offsetA)
    setJointMetaSetting(joint, 'offsetB', offsetB)

    registry.registerJoint(setId, joint)
    return joint
end

function lib.extractJoints(body)
    local joints = body:getJoints()
    local jointData = {}

    for _, joint in ipairs(joints) do
        local bodyA, bodyB = joint:getBodies()
        local otherBody = (bodyA == body) and bodyB or bodyA -- Determine the other connected body
        local jointType = joint:getType()
        local isBodyA = (bodyA == body)

        local data = {
            offsetA = getJointMetaSetting(joint, "offsetA"),
            offsetB = getJointMetaSetting(joint, "offsetB"),
            id = getJointId(joint),
            jointType = jointType,
            otherBody = otherBody,
            collideConnected = joint:getCollideConnected(),
            originalBodyOrder = isBodyA and "bodyA" or "bodyB",
        }

        local handler = jointHandlers[jointType]
        if not handler or not handler.extract then
            print("extract: Unsupported joint type: " .. jointType)
            goto continue
        end

        -- Extract additional data using the handler
        local additionalData = handler.extract(joint)
        for key, value in pairs(additionalData) do
            data[key] = value
        end

        table.insert(jointData, data)
        ::continue::
    end

    return jointData
end

function lib.recreateJoint(joint, newSettings)
    if joint:isDestroyed() then
        print("The joint is already destroyed.")
        return nil
    end

    local bodyA, bodyB = joint:getBodies()
    local jointType = joint:getType()

    local id = getJointId(joint)
    local offsetA = getJointMetaSetting(joint, "offsetA") or { x = 0, y = 0 }
    local offsetB = getJointMetaSetting(joint, "offsetB") or { x = 0, y = 0 }
    --  print(inspect(offsetA), inspect(offsetB))
    local data = { body1 = bodyA, body2 = bodyB, jointType = jointType, id = id, offsetA = offsetA, offsetB = offsetB, collideConnected =
    joint:getCollideConnected() }

    -- Add new settings to the data
    for key, value in pairs(newSettings or {}) do
        data[key] = value
    end

    local handler = jointHandlers[jointType]
    if not handler or not handler.extract then
        print("recreate extract: Unsupported joint type: " .. jointType)
    end

    -- Extract additional data using the handler
    local additionalData = handler.extract(joint)
    for key, value in pairs(additionalData) do
        data[key] = value
    end

    joint:destroy()

    -- Create a new joint with the updated data
    bodyA:setAwake(true)
    bodyB:setAwake(true)
    print(inspect(data))
    return lib.createJoint(data)
end

function lib.reattachJoints(jointData, newBody)
    for _, data in ipairs(jointData) do
        local jointType = data.jointType
        local otherBody = data.otherBody

        if data.originalBodyOrder == "bodyA" then
            data.body1 = newBody
            data.body2 = data.otherBody
        else
            data.body1 = data.otherBody
            data.body2 = newBody
        end

        -- Create the joint using the existing createJoint method
        lib.createJoint(data)
    end
end

function lib.doJointCreateUI(uiState, _x, _y, w, h)
    ui.panel(_x, _y, w, h, '∞ ' .. uiState.jointCreationMode.jointType .. ' ∞', function()
        local layout = ui.createLayout({
            type = 'columns',
            spacing = 10,
            startX = _x + 10,
            startY = _y + 10
        })

        local width = 180
        local x, y = ui.nextLayoutPosition(layout, 160, 50)
        local nextRow = function()
            x, y = ui.nextLayoutPosition(layout, 160, 50)
        end
        nextRow()
        if ui.button(x, y, width, 'Create') then
            local j = lib.createJoint(uiState.jointCreationMode)
            uiState.selectedJoint = j
            uiState.selectedObject = nil
            uiState.jointCreationMode = nil
        end

        if ui.button(x + width + 10, y, width, 'Cancel') then
            uiState.jointCreationMode = nil
        end
    end)
end

function lib.doJointUpdateUI(uiState, j, _x, _y, w, h)
    if not j:isDestroyed() then
        ui.panel(_x, _y, w, h, '∞ ' .. j:getType() .. ' ∞', function()
            local bodyA, bodyB = j:getBodies()
            if uiState.jointUpdateMode == nil then
                uiState.jointUpdateMode = { body1 = bodyA, body2 = bodyB, jointType = j:getType() }
            end
            local layout = ui.createLayout({
                type = 'columns',
                spacing = 10,
                startX = _x + 10,
                startY = _y + 10
            })
            local jointType = j:getType()
            local jointId = getJointId(j)
            local x, y = ui.nextLayoutPosition(layout, 160, 50)

            local nextRow = function()
                x, y = ui.nextLayoutPosition(layout, 160, 50)
            end
            nextRow()
            local width = 280


            if ui.button(x, y, width, 'destroy') then
                local setId = getJointId(j)
                registry.unregisterJoint(setId)
                j:destroy()
                return;
            end

            local function axisFunctionality(j)
                local axisEnabled = createCheckbox(' axis', x, y,
                    uiState.axisEnabled or false,
                    function(val)
                        uiState.axisEnabled = val
                    end
                )

                if axisEnabled then
                    local _x, _y = j:getAxis()
                    --_x, _y = normalizeAxis(_x, _y)
                    nextRow()
                    local axisX = createSliderWithId(jointId, ' axisX', x, y, 160, -1, 1,
                        _x or 0,
                        function(val)
                            uiState.selectedJoint = lib.recreateJoint(j, { axisX = val, axisY = _y })
                            j = uiState.selectedJoint
                        end
                    )
                    nextRow()
                    local axisY = createSliderWithId(jointId, ' axisY', x, y, 160, -1, 1,
                        _y or 1,
                        function(val)
                            uiState.selectedJoint = lib.recreateJoint(j, { axisX = _x, axisY = val })
                            j = uiState.selectedJoint
                        end
                    )
                    nextRow()
                    if ui.button(x, y, 160, 'normalize') then
                        local _x, _y = j:getAxis()
                        _x, _y = mathutils.normalizeAxis(_x, _y)
                        uiState.selectedJoint = lib.recreateJoint(j, { axisX = _x, axisY = _y })
                        j = uiState.selectedJoint
                    end
                end
                return j
            end

            local function collideFunctionality(j)
                local collideEnabled = createCheckbox(' collide', x, y,
                    j:getCollideConnected(),
                    function(val)
                        uiState.selectedJoint = lib.recreateJoint(j, { collideConnected = val })
                        j = uiState.selectedJoint
                    end
                )
                return j
            end

            local function motorFunctionality(j, settings)
                local motorEnabled = createCheckbox(' motor', x, y,
                    j:isMotorEnabled(),
                    function(val)
                        j:setMotorEnabled(val)
                    end
                )
                nextRow()
                if j:isMotorEnabled() then
                    local motorSpeed = createSliderWithId(jointId, ' speed', x, y, 160, -1000, 1000,
                        j:getMotorSpeed(),
                        function(val) j:setMotorSpeed(val) end
                    )
                    nextRow()
                    if (settings and settings.useTorque) then
                        local maxMotorTorque = createSliderWithId(jointId, ' max T', x, y, 160, 0, 100000,
                            j:getMaxMotorTorque(),
                            function(val) j:setMaxMotorTorque(val) end
                        )
                        nextRow()
                    end
                    if (settings and settings.useForce) then
                        local maxMotorForce = createSliderWithId(jointId, ' max F', x, y, 160, 0, 100000,
                            j:getMaxMotorForce(),
                            function(val) j:setMaxMotorForce(val) end
                        )
                        nextRow()
                    end
                end
            end

            local function limitsFunctionalityAngular(j)
                local limitsEnabled = createCheckbox(' limits', x, y,
                    j:areLimitsEnabled(),
                    function(val)
                        j:setLimitsEnabled(val)
                    end
                )

                if (j:areLimitsEnabled()) then
                    nextRow()
                    local up = math.deg(j:getUpperLimit())
                    local lowerLimit = createSliderWithId(jointId, ' lower', x, y, 160, -180, up,
                        math.deg(j:getLowerLimit()),
                        function(val)
                            local newValue = math.rad(val)

                            j:setLowerLimit(newValue)
                        end
                    )
                    nextRow()
                    local low = math.deg(j:getLowerLimit())
                    local upperLimit = createSliderWithId(jointId, ' upper', x, y, 160, low, 180,
                        math.deg(j:getUpperLimit()),
                        function(val)
                            local newValue = math.rad(val)
                            j:setUpperLimit(newValue)
                        end
                    )
                end
            end

            local function limitsFunctionalityLinear(j)
                local limitsEnabled = createCheckbox(' limits', x, y,
                    j:areLimitsEnabled(),
                    function(val)
                        j:setLimitsEnabled(val)
                    end
                )

                if (j:areLimitsEnabled()) then
                    nextRow()
                    local up = (j:getUpperLimit())
                    local lowerLimit = createSliderWithId(jointId, ' lower', x, y, 160, -1000, up,
                        j:getLowerLimit(),
                        function(val)
                            j:setLowerLimit(val)
                        end
                    )
                    nextRow()
                    local low = j:getLowerLimit()
                    local upperLimit = createSliderWithId(jointId, ' upper', x, y, 160, low, 1000,
                        j:getUpperLimit(),
                        function(val)
                            j:setUpperLimit(val)
                        end
                    )
                end
            end

            local function offsetSliders(j)
                if not getJointMetaSetting(j, 'offsetA') then
                    setJointMetaSetting(j, 'offsetA', { x = 0, y = 0 })
                end
                local offsetA = getJointMetaSetting(j, 'offsetA') or 0

                if not getJointMetaSetting(j, 'offsetB') then
                    setJointMetaSetting(j, 'offsetB', { x = 0, y = 0 })
                end
                local offsetB = getJointMetaSetting(j, 'offsetB') or 0

                function updateOffsetA(x, y)
                    --local rx, ry = rotatePoint(x, y, 0, 0, bodyA:getAngle())

                    offsetA.x = x
                    offsetA.y = y
                    setJointMetaSetting(j, 'offsetA', { x = offsetA.x, y = offsetA.y })
                    uiState.selectedJoint = lib.recreateJoint(j)
                    j = uiState.selectedJoint

                    if false then
                        -- keep this around because it will make offsetA unneeded.
                        local ax1, ay1, b1x2, b1y2 = j:getAnchors()
                        local fx, fy = mathutils.rotatePoint(ax1 - bodyA:getX(), ay1 - bodyA:getY(), 0, 0,
                            -bodyA:getAngle())
                        print('GREAT', fx, fy, x, y)
                    end
                    offsetHasChangedViaOutside = true
                    return j
                end

                function updateOffsetB(x, y)
                    --local rx, ry = rotatePoint(x, y, 0, 0, bodyA:getAngle())

                    offsetB.x = x
                    offsetB.y = y
                    setJointMetaSetting(j, 'offsetB', { x = offsetB.x, y = offsetB.y })
                    uiState.selectedJoint = lib.recreateJoint(j)
                    j = uiState.selectedJoint

                    if false then
                        -- keep this around because it will make offsetA unneeded.
                        local ax1, ay1, b1x2, b1y2 = j:getAnchors()
                        local fx, fy = mathutils.rotatePoint(ax1 - bodyA:getX(), ay1 - bodyA:getY(), 0, 0,
                            -bodyA:getAngle())
                        print('GREAT', fx, fy, x, y)
                    end
                    offsetHasChangedViaOutside = true
                    return j
                end

                -- Ensure offsets exist


                nextRow()
                if ui.button(x, y, 40, 'O') then
                    uiState.setOffsetAFunc = function(x, y)
                        local fx, fy = mathutils.rotatePoint(x - bodyA:getX(), y - bodyA:getY(), 0, 0, -bodyA:getAngle())
                        -- print(fx, fy)
                        return updateOffsetA(fx, fy)
                    end
                end
                if ui.button(x + 50, y, 40, '+') then
                    uiState.setOffsetBFunc = function(x, y)
                        local fx, fy = mathutils.rotatePoint(x - bodyB:getX(), y - bodyB:getY(), 0, 0, -bodyB:getAngle())
                        -- print(fx, fy)
                        return updateOffsetB(fx, fy)
                    end
                end
                nextRow()
                if (offsetHasChangedViaOutside) then offsetHasChangedViaOutside = false end

                local bodyA, bodyB = j:getBodies()
                local ud = bodyA:getUserData()


                if true and ud and ud.thing then
                    --print(inspect(ud.thing))
                    if ud.thing.width and ud.thing.height then
                        if ui.button(x, y, 30, '0', 30) then
                            updateOffsetA(0, -ud.thing.height / 2)
                        end
                        if ui.button(x + 30, y, 30, '1', 30) then
                            updateOffsetA(ud.thing.width / 2, -ud.thing.height / 2)
                        end
                        if ui.button(x + 60, y, 30, '2', 30) then
                            updateOffsetA(ud.thing.width / 2, 0)
                        end
                        if ui.button(x + 90, y, 30, '3', 30) then
                            updateOffsetA(ud.thing.width / 2, ud.thing.height / 2)
                        end
                        if ui.button(x + 120, y, 30, '4', 30) then
                            updateOffsetA(0, ud.thing.height / 2)
                        end
                        if ui.button(x + 150, y, 30, '5', 30) then
                            updateOffsetA(-ud.thing.width / 2, ud.thing.height / 2)
                        end
                        if ui.button(x + 180, y, 30, '6', 30) then
                            updateOffsetA(-ud.thing.width / 2, 0)
                        end
                        if ui.button(x + 210, y, 30, '7', 30) then
                            updateOffsetA(-ud.thing.width / 2, -ud.thing.height / 2)
                        end
                    end
                    if ui.button(x + 240, y, 30, '8', 30) then
                        updateOffsetA(0, 0)
                    end
                end

                nextRow()



                return j
            end

            if jointType == 'distance' then
                nextRow()
                j = collideFunctionality(j)
                nextRow()
                j = offsetSliders(j)
                nextRow()
                -- local bodyA, bodyB = j:getBodies()
                local x1, y1 = bodyA:getPosition()
                local x2, y2 = bodyB:getPosition()
                local myLength = math.sqrt((x2 - x1) ^ 2 + (y2 - y1) ^ 2)
                local length = createSliderWithId(jointId, ' length', x, y, 160, 0.1, 500,
                    uiState.jointUpdateMode.length or myLength,
                    function(val)
                        j:setLength(val)
                        uiState.jointUpdateMode.length = val
                    end
                )
                nextRow()

                local frequency = createSliderWithId(jointId, ' freq', x, y, 160, 0, 20,
                    j:getFrequency(),
                    function(val) j:setFrequency(val) end
                )
                nextRow()
                local damping = createSliderWithId(jointId, ' damp', x, y, 160, 0, 20,
                    j:getDampingRatio(),
                    function(val) j:setDampingRatio(val) end
                )

                nextRow()
                nextRow()
            elseif jointType == 'weld' then
                nextRow()
                j = collideFunctionality(j)
                nextRow()
                j = offsetSliders(j)
                nextRow()
                local frequency = createSliderWithId(jointId, ' freq', x, y, 160, 0, 20,
                    j:getFrequency(),
                    function(val) j:setFrequency(val) end
                )
                nextRow()
                local damping = createSliderWithId(jointId, ' damp', x, y, 160, 0, 20,
                    j:getDampingRatio(),
                    function(val) j:setDampingRatio(val) end
                )
                nextRow()
            elseif jointType == 'rope' then
                nextRow()
                j = collideFunctionality(j)
                nextRow()
                j = offsetSliders(j)
                nextRow()
                -- local bodyA, bodyB = j:getBodies()
                local x1, y1 = bodyA:getPosition()
                local x2, y2 = bodyB:getPosition()
                local myLength = math.sqrt((x2 - x1) ^ 2 + (y2 - y1) ^ 2)
                local length = createSliderWithId(jointId, ' length', x, y, 160, 0.1, 500,
                    uiState.jointUpdateMode.maxLength or myLength,
                    function(val)
                        j:setMaxLength(val)
                        uiState.jointUpdateMode.maxLength = val
                    end
                )
                nextRow()
            elseif jointType == 'revolute' then
                nextRow()
                j = collideFunctionality(j)
                nextRow()
                j = offsetSliders(j)
                nextRow()
                limitsFunctionalityAngular(j)
                nextRow()
                motorFunctionality(j, { useTorque = true })
            elseif jointType == 'wheel' then
                nextRow()
                j = collideFunctionality(j)
                nextRow()
                j = offsetSliders(j)
                nextRow()
                j = axisFunctionality(j)
                nextRow()
                -- if not j:isDestroyed() then
                local springFrequency = createSliderWithId(jointId, ' spring F', x, y, 160, 0, 100,
                    j:getSpringFrequency(),
                    function(val)
                        j:setSpringFrequency(val)
                    end
                )
                nextRow()
                local springDamping = createSliderWithId(jointId, ' spring D', x, y, 160, 0, 1,
                    j:getSpringDampingRatio(),
                    function(val) j:setSpringDampingRatio(val) end
                )
                nextRow()
                motorFunctionality(j, { useTorque = true })
                -- axisFunctionality(j)
                nextRow()
                --  end
            elseif jointType == 'motor' then
                nextRow()
                j = collideFunctionality(j)
                nextRow()
                j = offsetSliders(j)
                nextRow()
                local angularOffset = createSliderWithId(jointId, ' angular o', x, y, 160, -180, 180,
                    math.deg(j:getAngularOffset()),
                    function(val) j:setAngularOffset(math.rad(val)) end
                )
                nextRow()
                local correctionF = createSliderWithId(jointId, ' corr.', x, y, 160, 0, 1,
                    j:getCorrectionFactor(),
                    function(val) j:setCorrectionFactor(val) end
                )
                nextRow()
                local lx, ly = j:getLinearOffset()
                local lxOff = createSliderWithId(jointId, ' lx', x, y, 160, -1000, 1000,
                    lx,
                    function(val) j:setLinearOffset(val, ly) end
                )
                nextRow()
                local lyOff = createSliderWithId(jointId, ' ly', x, y, 160, -1000, 1000,
                    ly,
                    function(val) j:setLinearOffset(lx, val) end
                )
                nextRow()
                local maxForce = createSliderWithId(jointId, ' force', x, y, 160, 0, 100000,
                    j:getMaxForce(),
                    function(val) j:setMaxForce(val) end
                )
                nextRow()
                local maxTorque = createSliderWithId(jointId, ' torque', x, y, 160, 0, 100000,
                    j:getMaxTorque(),
                    function(val) j:setMaxTorque(val) end
                )
                nextRow()
            elseif jointType == 'prismatic' then
                nextRow()
                j = collideFunctionality(j)
                nextRow()
                j = offsetSliders(j)
                nextRow()
                j = axisFunctionality(j)
                nextRow()
                limitsFunctionalityLinear(j)
                nextRow()
                motorFunctionality(j, { useForce = true })
            end
        end)
    end
end

return lib
--math-utils.lua
local lib = {}



-- Utility function to check if a point is inside a polygon.
-- Implements the ray-casting algorithm.
local function pointInPath(x, y, poly)
    local inside = false
    local n = #poly
    for i = 1, n, 2 do
        local j = (i + 2) % n
        if j == 0 then j = n end
        local xi, yi = poly[i], poly[i + 1]
        local xj, yj = poly[j], poly[j + 1]

        local intersect = ((yi > y) ~= (yj > y)) and
            (x < (xj - xi) * (y - yi) / (yj - yi + 1e-10) + xi)
        if intersect then
            inside = not inside
        end
    end
    return inside
end
function lib.pointInRect(px, py, rect)
    return px >= rect.x and px <= (rect.x + rect.width) and
        py >= rect.y and py <= (rect.y + rect.height)
end

local function distancePointToSegment(px, py, x1, y1, x2, y2)
    local dx = x2 - x1
    local dy = y2 - y1

    if dx == 0 and dy == 0 then
        -- The segment is a single point
        local dist = math.sqrt((px - x1) ^ 2 + (py - y1) ^ 2)
        return dist, { x = x1, y = y1 }
    end

    -- Calculate the t that minimizes the distance
    local t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy)

    -- Clamp t to the [0,1] range
    t = math.max(0, math.min(1, t))

    -- Find the closest point on the segment
    local closestX = x1 + t * dx
    local closestY = y1 + t * dy

    -- Calculate the distance
    local dist = math.sqrt((px - closestX) ^ 2 + (py - closestY) ^ 2)

    return dist, { x = closestX, y = closestY }
end
-- Function to find the closest edge to a given point
-- Returns the index of the first vertex of the closest edge
function lib.findClosestEdge(verts, px, py)
    local minDist = math.huge
    local closestEdgeIndex = nil

    local numVertices = #verts / 2

    for i = 1, numVertices do
        local j = (i % numVertices) + 1 -- Next vertex (wrap around)
        local x1 = verts[(i - 1) * 2 + 1]
        local y1 = verts[(i - 1) * 2 + 2]
        local x2 = verts[(j - 1) * 2 + 1]
        local y2 = verts[(j - 1) * 2 + 2]

        local dist, _ = distancePointToSegment(px, py, x1, y1, x2, y2)

        if dist < minDist then
            minDist = dist
            closestEdgeIndex = i -- Insert after vertex i
        end
    end

    return closestEdgeIndex
end

function lib.findClosestVertex(verts, px, py)
    local minDistSq = math.huge
    local closestVertexIndex = nil

    local numVertices = #verts / 2

    for i = 1, numVertices do
        local vx = verts[(i - 1) * 2 + 1]
        local vy = verts[(i - 1) * 2 + 2]
        local dx = px - vx
        local dy = py - vy
        local distSq = dx * dx + dy * dy

        if distSq < minDistSq then
            minDistSq = distSq
            closestVertexIndex = i
        end
    end

    return closestVertexIndex
end

function lib.normalizeAxis(x, y)
    local magnitude = math.sqrt(x ^ 2 + y ^ 2)
    if magnitude == 0 then
        return 1, 0 -- Default to (1, 0) if the vector is zero
    else
        --   print('normalizing', x / magnitude, y / magnitude)
        return x / magnitude, y / magnitude
    end
end

function lib.calculateDistance(x1, y1, x2, y2)
    local dx = x2 - x1
    local dy = y2 - y1
    return math.sqrt(dx * dx + dy * dy)
end

function lib.computeCentroid(polygon)
    local sumX, sumY = 0, 0
    for i = 1, #polygon, 2 do
        --for _, vertex in ipairs(vertices) do
        sumX = sumX + polygon[i]
        sumY = sumY + polygon[i + 1]
        -- end
    end
    local count = (#polygon / 2)
    return sumX / count, sumY / count
end

function lib.rotatePoint(x, y, originX, originY, angle)
    -- Translate the point to the origin
    local translatedX = x - originX
    local translatedY = y - originY

    -- Apply rotation
    local rotatedX = translatedX * math.cos(angle) - translatedY * math.sin(angle)
    local rotatedY = translatedX * math.sin(angle) + translatedY * math.cos(angle)

    -- Translate back to the original position
    local finalX = rotatedX + originX
    local finalY = rotatedY + originY

    return finalX, finalY
end

-- localtoworld
function lib.getLocalVerticesForCustomSelected(vertices, obj, cx, cy)
    local verts = vertices
    local offX, offY = obj.body:getPosition()
    local angle = obj.body:getAngle()
    local result = {}

    for i = 1, #verts, 2 do
        local rx, ry = lib.rotatePoint(verts[i] - cx, verts[i + 1] - cy, 0, 0, angle)
        local vx, vy = offX + rx, offY + ry
        table.insert(result, vx)
        table.insert(result, vy)
    end
    return result
end

-- Function to convert world coordinates to local coordinates of a shape
function lib.worldToLocal(worldX, worldY, angle, cx, cy)
    -- Get the body's position and angle
    -- local offX, offY = obj.body:getPosition()
    --local angle = obj.body:getAngle()

    -- Step 1: Translate the world point to the body's origin
    local translatedX = worldX -- offX
    local translatedY = worldY -- offY

    -- Step 2: Rotate the point by -angle to align with the local coordinate system
    local cosA = math.cos(-angle)
    local sinA = math.sin(-angle)
    local rotatedX = translatedX * cosA - translatedY * sinA
    local rotatedY = translatedX * sinA + translatedY * cosA

    -- Step 3: Adjust for the centroid offset
    local localX = rotatedX + cx
    local localY = rotatedY + cy

    return localX, localY
end

-- Function to remove a vertex from the table based on its vertex index
-- verts: flat list {x1, y1, x2, y2, ...}
-- vertexIndex: the index of the vertex to remove (1, 2, 3, ...)
function lib.removeVertexAt(verts, vertexIndex)
    local posX = (vertexIndex - 1) * 2 + 1
    local posY = posX + 1

    -- Remove y-coordinate first to prevent shifting issues
    table.remove(verts, posY)
    table.remove(verts, posX)
end

function lib.insertValuesAt(tbl, pos, val1, val2)
    table.insert(tbl, pos, val1)
    table.insert(tbl, pos + 1, val2)
end

-- decompose_complex.lua
-- A module for decomposing complex polygons into simpler polygons by handling intersections.



-- Function to find the intersection point between two line segments.
local function getLineIntersection(p0_x, p0_y, p1_x, p1_y, p2_x, p2_y, p3_x, p3_y)
    local s1_x = p1_x - p0_x
    local s1_y = p1_y - p0_y
    local s2_x = p3_x - p2_x
    local s2_y = p3_y - p2_y

    local denom = (-s2_x * s1_y + s1_x * s2_y)
    if denom == 0 then return nil end -- Parallel lines

    local s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / denom
    local t = (s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / denom

    if s >= 0 and s <= 1 and t >= 0 and t <= 1 then
        local intersect_x = p0_x + (t * s1_x)
        local intersect_y = p0_y + (t * s1_y)
        return intersect_x, intersect_y
    end

    return nil
end

-- Function to find all collision points (intersections) within a polygon.
local function getCollisions(poly)
    local collisions = {}
    local n = #poly

    for outeri = 1, n, 2 do
        local ax, ay = poly[outeri], poly[outeri + 1]
        local ni = outeri + 2
        if ni > n then ni = 1 end
        local bx, by = poly[ni], poly[ni + 1]

        for inneri = 1, n, 2 do
            -- Skip adjacent edges
            if inneri ~= outeri and inneri ~= ((outeri + 2 - 1) % n) + 1 then
                local cx, cy = poly[inneri], poly[inneri + 1]
                local ni_inner = inneri + 2
                if ni_inner > n then ni_inner = 1 end
                local dx, dy = poly[ni_inner], poly[ni_inner + 1]

                local ix, iy = getLineIntersection(ax, ay, bx, by, cx, cy, dx, dy)
                if ix and iy then
                    -- Avoid adding shared vertices as intersections
                    if not ((ax == cx and ay == cy) or (ax == dx and ay == dy) or
                            (bx == cx and by == cy) or (bx == dx and by == dy)) then
                        local collision = { i1 = outeri, i2 = inneri, x = ix, y = iy }
                        -- Check for duplicate collisions
                        local duplicate = false
                        for _, existing in ipairs(collisions) do
                            if (existing.i1 == collision.i2 and existing.i2 == collision.i1) then
                                duplicate = true
                                break
                            end
                        end
                        if not duplicate then
                            table.insert(collisions, collision)
                        end
                    end
                end
            end
        end
    end

    return collisions
end

-- Function to split a polygon into two at a given intersection point.
local function splitPoly(poly, intersection)
    local function getIndices()
        local biggestIndex = math.max(intersection.i1, intersection.i2)
        local smallestIndex = math.min(intersection.i1, intersection.i2)
        return smallestIndex, biggestIndex
    end

    local smallestIndex, biggestIndex = getIndices()
    local wrap = {}
    local back = {}
    local bb = biggestIndex

    -- Build the 'wrap' polygon
    while bb ~= smallestIndex do
        bb = bb + 2
        if bb > #poly - 1 then
            bb = 1
        end
        table.insert(wrap, poly[bb])
        table.insert(wrap, poly[bb + 1])
    end
    table.insert(wrap, intersection.x)
    table.insert(wrap, intersection.y)

    -- Build the 'back' polygon
    local bk = biggestIndex
    while bk ~= smallestIndex do
        table.insert(back, poly[bk])
        table.insert(back, poly[bk + 1])
        bk = bk - 2
        if bk < 1 then
            bk = #poly - 1
        end
    end
    table.insert(back, intersection.x)
    table.insert(back, intersection.y)

    return wrap, back
end


local function tableConcat(t1, t2)
    for i = 1, #t2 do
        table.insert(t1, t2[i])
    end
    return t1
end

function lib.decompose(poly, result)
    result = result or {}
    local intersections = getCollisions(poly)

    if #intersections == 0 then
        tableConcat(result, { poly })
        return result
    end

    -- Process only the first intersection to avoid redundant splits
    local intersection = intersections[1]
    local p1, p2 = splitPoly(poly, intersection)

    -- Recursively decompose the resulting polygons
    lib.decompose(p1, result)
    lib.decompose(p2, result)

    return result
end

return lib
-- object-manager.lua
local lib = {}
local shapes = require 'src.shapes'
local uuid = require 'src.uuid'
local registry = require 'src.registry'
local joints = require 'src.joints'
local jointHandlers = require 'src.joint-handlers'
local inspect = require 'vendor.inspect'
local utils = require 'src.utils'
-- Helper function to create and configure a physics body with shapes
local function createThing(shapeType, x, y, bodyType, radius, width, height, label, optionalVertices)
    -- Initialize default values
    bodyType = bodyType or 'dynamic'
    radius = radius or 20         -- Default radius for circular shapes
    width = width or radius * 2   -- Default width for polygonal shapes
    height = height or radius * 2 -- Default height for polygonal shapes
    label = label or ""           -- Default label

    -- Create the physics body at the specified world coordinates
    local body = love.physics.newBody(world, x, y, bodyType)

    local shapeList, vertices = shapes.createShape(shapeType, radius, width, height, optionalVertices)

    if not shapeList then
        print("Failed to create shapes for:", shapeType)
        return nil
    end

    -- Attach fixtures to the body for each shape
    for _, shape in ipairs(shapeList) do
        local fixture = love.physics.newFixture(body, shape, 1)
        fixture:setRestitution(0.3) -- Set bounciness
    end

    -- Configure body properties
    body:setAwake(true)

    -- Create the 'thing' table to store properties
    local thing = {
        shapeType = shapeType,
        radius = radius,
        width = width,
        height = height,
        label = label,
        body = body,
        shapes = shapeList,
        vertices = vertices, -- Store vertices if needed
        id = uuid.generateID(),
    }

    -- Set user data for easy access
    body:setUserData({ thing = thing })

    -- Register the body in the registry
    registry.registerBody(thing.id, body)

    return thing
end

function lib.startSpawn(shapeType, wx, wy)
    local radius = tonumber(uiState.lastUsedRadius) or 10
    local width = tonumber(uiState.lastUsedWidth) or radius * 2   -- Default width for polygons
    local height = tonumber(uiState.lastUsedHeight) or radius * 2 -- Default height for polygons

    local bodyType = uiState.nextType
    local thing = createThing(shapeType, wx, wy, bodyType, radius, width, height, '')

    if not thing then
        print("startSpawn: Failed to create thing.")
        return
    end

    uiState.draggingObj = thing
    uiState.offsetDragging = { 0, 0 }
end

function lib.addThing(shapeType, x, y, bodyType, radius, width, height, label, optionalVertices)
    local thing = createThing(shapeType, x, y, bodyType, radius, width, height, label, optionalVertices)

    if not thing then
        print("addThing: Failed to create thing.")
        return nil
    end

    return thing
end

function lib.recreateThingFromBody(body, newSettings)
    if body:isDestroyed() then
        print("The body is already destroyed.")
        return nil
    end
    local userData = body:getUserData()
    local thing = userData and userData.thing
    -- Extract current properties
    local x, y = body:getPosition()
    local angle = body:getAngle()
    local velocityX, velocityY = body:getLinearVelocity()
    local angularVelocity = body:getAngularVelocity()
    local bodyType = newSettings.bodyType or body:getType()
    local firstFixture = body:getFixtures()[1]
    local restitution = firstFixture:getRestitution()
    local friction = firstFixture:getFriction()
    local fixedRotation = body:isFixedRotation() -- Capture fixed angle state
    -- Get the original `thing` for shape info


    local jointData = joints.extractJoints(body)
    -- Destroy the old body
    body:destroy()

    -- Create new body
    local newBody = love.physics.newBody(world, x, y, bodyType)
    newBody:setAngle(angle)
    newBody:setLinearVelocity(velocityX, velocityY)
    newBody:setAngularVelocity(angularVelocity)
    newBody:setFixedRotation(fixedRotation) -- Reapply fixed rotation
    -- Create a new shape

    local shapeList, newVertices = shapes.createShape(
        newSettings.shapeType or thing.shapeType,
        newSettings.radius or thing.radius,
        newSettings.width or thing.width,
        newSettings.height or thing.height,
        newSettings.optionalVertices
    )

    for _, shape in ipairs(shapeList) do
        local fixture = love.physics.newFixture(newBody, shape, 1)
        fixture:setRestitution(newSettings.restitution or restitution)
        fixture:setFriction(newSettings.friction or friction)
    end



    -- Update the `thing` table
    thing.label = thing.label
    thing.body = newBody
    thing.shapes = shapeList

    thing.radius = newSettings.radius or thing.radius
    thing.width = newSettings.width or thing.width
    thing.height = newSettings.height or thing.height
    thing.id = thing.id or uuid.generateID()
    thing.vertices = newVertices
    registry.registerBody(thing.id, thing.body)
    newBody:setUserData({ thing = thing })

    joints.reattachJoints(jointData, newBody)

    return thing
end

function lib.destroyBody(body)
    local thing = body:getUserData().thing
    local joints = body:getJoints()
    for i = 1, #joints do
        local ud = joints[i]:getUserData()
        if ud then
            registry.unregisterJoint(ud.id)
            joints[i]:destroy()
        end
    end
    registry.unregisterBody(thing.id)
    body:destroy()
end

-- Helper function to collect all connected bodies
local function collectBodies(thing, collected)
    collected = collected or {}
    if not thing or not thing.body or collected[thing.id] then
        return collected
    end
    collected[thing.id] = thing.body
    for _, joint in ipairs(thing.body:getJoints()) do
        local bodyA, bodyB = joint:getBodies()
        local otherBody = (bodyA == thing.body) and bodyB or bodyA
        local otherThing = otherBody:getUserData() and otherBody:getUserData().thing
        if otherThing then
            collectBodies(otherThing, collected)
        end
    end
    return collected
end
-- -- Rotates a point (x, y) by angle radians
-- local function rotatePoint(x, y, angle)
--     local cosA = math.cos(angle)
--     local sinA = math.sin(angle)
--     return x * cosA - y * sinA, x * sinA + y * cosA
-- end
-- Function to calculate centroid
local function calculateCentroid(thing)
    local bodies = collectBodies(thing)
    local totalMass = 0
    local sumX, sumY = 0, 0
    for id, body in pairs(bodies) do
        local mass = body:getMass()
        local x, y = body:getPosition()
        sumX = sumX + x * mass
        sumY = sumY + y * mass
        totalMass = totalMass + mass
    end
    if totalMass == 0 then
        return 0, 0 -- Avoid division by zero
    end
    return sumX / totalMass, sumY / totalMass
end

function lib.flipThing(thing, axis, recursive)
    -- print('************* Flipping Thing *************')

    -- Validate input
    if not thing or not thing.body then
        print("flipThing: Invalid 'thing' provided.")
        return
    end

    if axis ~= 'x' and axis ~= 'y' then
        print("flipThing: Invalid axis. Use 'x' or 'y'.")
        return
    end

    -- Tables to keep track of processed bodies and joints
    local processedBodies = {}
    local processedJoints = {}
    local toBeProcessedJoints = {}
    local centroidX, centroidY = calculateCentroid(thing)


    -- Phase 1: Flip All Bodies
    local function flipBody(currentThing)
        --print('called flipbody')
        local currentBody = currentThing.body
        if not currentBody or processedBodies[currentThing.id] then
            return
        end

        processedBodies[currentThing.id] = true

        -- Get current position and angle
        local currentX, currentY = currentBody:getPosition()
        local currentAngle = currentBody:getAngle()

        -- Calculate relative position to centroid
        local relX = currentX - centroidX
        local relY = currentY - centroidY

        -- Determine new relative position based on flip axis
        local newRelX, newRelY
        if axis == 'x' then
            newRelX = -relX
            newRelY = relY
        elseif axis == 'y' then
            newRelX = relX
            newRelY = -relY
        end
        -- Calculate new absolute position
        local newX = centroidX + newRelX
        local newY = centroidY + newRelY
        local newAngle
        if axis == 'x' then
            newAngle = -currentAngle
        elseif axis == 'y' then
            newAngle = -currentAngle
        end

        -- Update body's position and angle
        currentThing.body:setPosition(newX, newY)
        currentThing.body:setAngle(newAngle)


        if currentThing.vertices then
            --print('jojjo!')
            local flippedVertices = utils.shallowCopy(currentThing.vertices)
            for i = 1, #currentThing.vertices, 2 do
                if axis == 'x' then
                    flippedVertices[i] = -flippedVertices[i]         -- Invert X coordinate
                elseif axis == 'y' then
                    flippedVertices[i + 1] = -flippedVertices[i + 1] -- Invert Y coordinate
                end
            end
            currentThing.vertices = flippedVertices
        end

        -- Flip each fixture's shape
        for _, fixture in ipairs(currentBody:getFixtures()) do
            local shape = fixture:getShape()
            if shape:typeOf("PolygonShape") then
                local points = { shape:getPoints() }
                for i = 1, #points, 2 do
                    if axis == 'x' then
                        points[i] = -points[i]         -- Invert X coordinate
                    elseif axis == 'y' then
                        points[i + 1] = -points[i + 1] -- Invert Y coordinate
                    end
                end
                -- currentThing.vertices = points;
                -- Create a new shape with flipped vertices
                local success, newShape = pcall(love.physics.newPolygonShape, unpack(points))
                if not success then
                    print("flipThing: Failed to create new PolygonShape:", newShape)
                else
                    -- Preserve fixture properties
                    local density = fixture:getDensity()
                    local friction = fixture:getFriction()
                    local restitution = fixture:getRestitution()

                    -- Create a new fixture and destroy the old one
                    local newFixture = love.physics.newFixture(currentBody, newShape, density)
                    newFixture:setFriction(friction)
                    newFixture:setRestitution(restitution)
                    fixture:destroy()
                end
            elseif shape:typeOf("CircleShape") then
                -- No need to flip circle shapes beyond position
                -- Circle radius remains the same
                -- If the circle has user data affecting orientation, handle it here
            end
        end

        -- Determine new angle based on flip axis

        -- If recursive, flip connected bodies first
        if recursive then
            for _, joint in ipairs(currentBody:getJoints()) do
                local jointUserData = joint:getUserData()
                if not jointUserData or not jointUserData.id then
                    print("flipThing: Joint without valid user data encountered.")
                    goto continue
                end

                toBeProcessedJoints[jointUserData.id] = joint
                -- Determine the other body connected by the joint
                local bodyA, bodyB = joint:getBodies()
                local otherBody = (bodyA == currentBody) and bodyB or bodyA
                local otherThing = otherBody:getUserData() and otherBody:getUserData().thing

                if not otherThing then
                    print("flipThing: Connected joint's other body is invalid.")
                    goto continue
                end

                -- Recursively flip the connected body
                flipBody(otherThing)

                ::continue::
            end
        end
    end

    -- Phase 2: Flip All Joints
    local function flipJoints()
        for jointID, joint in pairs(toBeProcessedJoints) do
            local jointType = joint:getType()
            local jointUserData = joint:getUserData()

            if not jointUserData or not jointUserData.id then
                print("flipThing: Joint without valid user data encountered.")
                goto continue
            end

            if processedJoints[jointUserData.id] then
                goto continue
            end
            processedJoints[jointUserData.id] = true

            -- Extract joint data using the handler
            local handler = jointHandlers[jointType]
            if not handler or not handler.extract then
                print("flipThing: No handler found for joint type:", jointType)
                goto continue
            end
            local jointData = handler.extract(joint)

            -- Determine the connected bodies
            local bodyA, bodyB = joint:getBodies()
            local thingA = bodyA:getUserData() and bodyA:getUserData().thing
            local thingB = bodyB:getUserData() and bodyB:getUserData().thing

            if not thingA or not thingB then
                print("flipThing: One or both connected things are invalid.")
                goto continue
            end

            local offsetA = jointUserData.offsetA
            local offsetB = jointUserData.offsetB
            --print('before', inspect(offsetA), inspect(offsetB))
            if axis == 'x' then
                offsetA.x = -offsetA.x
                offsetB.x = -offsetB.x
            elseif axis == 'y' then
                offsetA.y = -offsetA.y
                offsetB.y = -offsetB.y
            end


            joints.recreateJoint(joint, { offsetA = offsetA, offsetB = offsetB })

            ::continue::
        end
    end

    -- Phase 1: Flip All Bodies Recursively
    flipBody(thing)

    -- Phase 2: Flip All Joints
    flipJoints()

    --print('************* Flip Completed *************')
    return thing
end

return lib
-- src/registry.lua
local utils = require 'src.utils'

local registry = {
    bodies = {}, -- [id] = body
    joints = {}, -- [id] = joint
    -- Add more categories if needed
}


-- Register a body
function registry.registerBody(id, body)
    registry.bodies[id] = body
    print('bodies:', utils.tablelength(registry.bodies))
end

-- Unregister a body
function registry.unregisterBody(id)
    registry.bodies[id] = nil
    --print('bodies:', tablelength(registry.bodies))
end

-- Get a body by ID
function registry.getBodyByID(id)
    return registry.bodies[id]
end

-- Register a joint
function registry.registerJoint(id, joint)
    registry.joints[id] = joint
    --print('joints:', tablelength(registry.joints))
    print('joints:', utils.tablelength(registry.joints))
end

-- Unregister a joint
function registry.unregisterJoint(id)
    registry.joints[id] = nil
    print('joints:', utils.tablelength(registry.joints))
end

-- Get a joint by ID
function registry.getJointByID(id)
    return registry.joints[id]
end

-- Reset the registry (useful when loading a new world)
function registry.reset()
    registry.bodies = {}
    registry.joints = {}
end

return registry
--script.lua
local script = {}
local inspect = require 'vendor.inspect'

function getObjectsByLabel(label)
    local objects = {}
    for _, body in pairs(world:getBodies()) do
        local userData = body:getUserData()
        if (userData and userData.thing and userData.thing.label == label) then
            table.insert(objects, userData.thing)
        end
    end
    return objects
end

local scriptEnv = {
    ipairs            = ipairs,
    table             = table,
    inspect           = inspect,
    print             = print,
    math              = math,
    love              = love,
    random            = love.math.random,
    getObjectsByLabel = getObjectsByLabel,
    world             = world
    -- Add global utilities like NeedManager, etc.
    --broadcastEvent = function(eventName, data)
    -- Implementation for event broadcasting
    --end,
}

function script.setEnv(newEnv)
    for key, value in pairs(newEnv) do
        scriptEnv[key] = value
    end
end

function script.loadScript(data, filePath)
    --print('>>>>> script environment api')
    --printTableKeys(scriptEnv)
    --print('>>>>>')
    local scriptContent = data
    if not scriptContent then
        error("Script not found: " .. filePath)
    end

    local chunk, err = load(scriptContent, "@" .. filePath, "t", scriptEnv)
    if not chunk then
        error("Error loading script: " .. err)
    end

    local success, err = pcall(chunk)
    if not success then
        error("Error executing script: " .. err)
    end

    print("Script loaded: " .. filePath)
    if success then
        return chunk
    end
end

return script
--selection-rect.lua
local lib = {}
local mathutils = require 'src.math-utils'
-- Include the drawDottedLine function here
local function drawDottedLine(x1, y1, x2, y2, dotSize, spacing)
    local dx = x2 - x1
    local dy = y2 - y1
    local distance = math.sqrt(dx * dx + dy * dy)

    local numDots = math.floor(distance / spacing)

    local stepX = dx / distance
    local stepY = dy / distance

    for i = 0, numDots do
        local cx = x1 + stepX * spacing * i
        local cy = y1 + stepY * spacing * i
        love.graphics.rectangle("fill", cx, cy, dotSize, dotSize)
    end
end

-- Convert local shape vertices to world coordinates based on the body's position and angle
local function getShapeWorldPoints(body, shape)
    local points = {}
    local angle = body:getAngle()
    local xBody, yBody = body:getPosition()

    if shape:typeOf("CircleShape") then
        -- For circles, represent as the center point
        table.insert(points, { x = xBody, y = yBody })
    elseif shape:typeOf("PolygonShape") or shape:typeOf("EdgeShape") then
        local points2 = { shape:getPoints() }

        for i = 1, #points2, 2 do
            local localX, localY = points2[i], points2[i + 1]
            -- Apply rotation
            local rotatedX = localX * math.cos(angle) - localY * math.sin(angle)
            local rotatedY = localX * math.sin(angle) + localY * math.cos(angle)
            -- Translate to world coordinates
            local worldX = xBody + rotatedX
            local worldY = yBody + rotatedY
            table.insert(points, { x = worldX, y = worldY })
        end
    elseif shape:typeOf("RectangleShape") then
        print('NOT HANDLING THIS SHAPE RectangleShape')
        -- Handle RectangleShape if using a custom shape type
        -- Love2D does not have a native RectangleShape; rectangles are typically PolygonShapes
    else
        print('NOT HANDLING THIS SHAPE ??')
    end

    return points
end



function lib.draw(selection)
    local x, y = love.mouse:getPosition()
    local tlx = math.min(selection.x, x)
    local tly = math.min(selection.y, y)
    local brx = math.max(selection.x, x)
    local bry = math.max(selection.y, y)
    -- print(inspect(selection), x, y)
    drawDottedLine(tlx, tly, brx, tly, 5, 10)
    drawDottedLine(brx, tly, brx, bry, 5, 10)
    drawDottedLine(tlx, bry, brx, bry, 5, 10)
    drawDottedLine(tlx, tly, tlx, bry, 5, 10)
end

function lib.selectWithin(world, rect)
    local bodiesInside = {}
    for _, body in pairs(world:getBodies()) do
        local userData = body:getUserData()
        local thing = userData and userData.thing
        if thing then
            local fixtures = body:getFixtures()
            local allFixturesInside = true
            for _, fixture in ipairs(fixtures) do
                local shape = fixture:getShape()
                local worldPoints = getShapeWorldPoints(body, shape)

                -- For each point of the shape, check if it's inside the rectangle
                for _, point in ipairs(worldPoints) do
                    if not mathutils.pointInRect(point.x, point.y, rect) then
                        allFixturesInside = false
                        break -- No need to check further points
                    end
                end
                if not allFixturesInside then
                    break -- No need to check further fixtures
                end
            end
            if allFixturesInside then
                table.insert(bodiesInside, thing)
            end
        end
    end
    return bodiesInside
end

return lib
-- shapes.lua

local mathutils = require 'src.math-utils'
local utils = require 'src.utils'
local inspect = require 'vendor.inspect'
local shapes = {}

local function makePolygonVertices(sides, radius)
    local vertices = {}
    local angleStep = (2 * math.pi) / sides
    local rotationOffset = math.pi / 2 -- Rotate so one vertex is at the top
    for i = 0, sides - 1 do
        local angle = i * angleStep - rotationOffset
        local x = radius * math.cos(angle)
        local y = radius * math.sin(angle)
        table.insert(vertices, x)
        table.insert(vertices, y)
    end
    return vertices
end

local function capsuleXY(w, h, cs, x, y)
    -- cs == cornerSize
    local w2 = w / 2
    local h2 = h / 2

    local bt = -h2 + cs
    local bb = h2 - cs
    local bl = -w2 + cs
    local br = w2 - cs

    return {
        x - w2, y + bt,
        x + bl, y - h2,
        x + br, y - h2,
        x + w2, y + bt,
        x + w2, y + bb,
        x + br, y + h2,
        x + bl, y + h2,
        x - w2, y + bb
    }
end

local function makeTrapezium(w, w2, h, x, y)
    return {
        x - w / 2, y - h / 2,
        x + w / 2, y - h / 2,
        x + w2 / 2, y + h / 2,
        x - w2 / 2, y + h / 2
    }
end

local function makeITriangle(w, h, x, y)
    return {
        x - w / 2, y + h / 2,
        x + w / 2, y + h / 2,
        x, y - h / 2
    }
end

local function makeShapeListFromPolygon(polygon)
    local shapesList = {}
    local allowComplex = true -- TODO: parameterize this
    local triangles = {}

    -- first figure out if we are maybe a simple polygon we can use -as is- by box2d
    if #polygon <= 16 and love.math.isConvex(polygon) then
        --print('cause its simple!')
        local centroidX, centroidY = mathutils.computeCentroid(polygon)
        local localVertices = {}
        for i = 1, #polygon, 2 do
            local x = polygon[i] - centroidX
            local y = polygon[i + 1] - centroidY
            table.insert(localVertices, x)
            table.insert(localVertices, y)
        end
        table.insert(shapesList, love.physics.newPolygonShape(localVertices))
    else                     -- ok we are not the simplest polygons we need more work,
        if allowComplex then -- when this is true we also solve, self intersecting and everythign
            local result = {}
            local success, err = pcall(function()
                mathutils.decompose(polygon, result)
            end)

            if not success then
                print("Error in decompose_complex_poly: " .. err)
                return nil -- Exit early if decomposition fails
            end

            for i = 1, #result do
                local success, tris = pcall(love.math.triangulate, result[i])
                if success then
                    utils.tableConcat(triangles, tris)
                else
                    print("Failed to triangulate part of the polygon: " .. tris)
                end
            end
        else -- this is a bit of a nono, its no longer really in use and doenst fix all werid cases. faster though.
            local success, result = pcall(love.math.triangulate, polygon)
            if success then
                triangles = result
            else
                print("Failed to triangulate polygon: " .. result)
                return nil -- Exit early if triangulation fails
            end
        end

        if #triangles == 0 then
            print("No valid triangles were created.")
            return nil
        end
        local centroidX, centroidY = mathutils.computeCentroid(polygon)
        for _, triangle in ipairs(triangles) do
            -- Adjust triangle vertices relative to body position
            local localVertices = {}
            for i = 1, #triangle, 2 do
                local x = triangle[i] - centroidX
                local y = triangle[i + 1] - centroidY
                table.insert(localVertices, x)
                table.insert(localVertices, y)
            end

            local shapeSuccess, shape = pcall(love.physics.newPolygonShape, localVertices)
            if shapeSuccess then
                table.insert(shapesList, shape)
            else
                print("Failed to create shape for triangle: " .. shape)
            end
        end
    end
    return shapesList
end

function shapes.createShape(shapeType, radius, width, height, optionalVertices)
    if (radius == 0) then radius = 1 end
    if (width == 0) then width = 1 end
    if (height == 0) then height = 1 end

    local shapesList = {}
    local vertices = nil

    if shapeType == 'circle' then
        table.insert(shapesList, love.physics.newCircleShape(radius))
    elseif shapeType == 'rectangle' then
        table.insert(shapesList, love.physics.newRectangleShape(width, height))
    elseif shapeType == 'capsule' then
        vertices = capsuleXY(width, height, width / 5, 0, 0)
        table.insert(shapesList, love.physics.newPolygonShape(vertices))
    elseif shapeType == 'trapezium' then
        vertices = makeTrapezium(width, width * 1.2, height, 0, 0)
        table.insert(shapesList, love.physics.newPolygonShape(vertices))
    elseif shapeType == 'itriangle' then
        vertices = makeITriangle(width, height, 0, 0)
        table.insert(shapesList, love.physics.newPolygonShape(vertices))
    else
        local sides = ({
            triangle = 3,
            pentagon = 5,
            hexagon = 6,
            heptagon = 7,
            octagon = 8,
        })[shapeType]

        if sides then
            vertices = makePolygonVertices(sides, radius)
            table.insert(shapesList, love.physics.newPolygonShape(vertices))
        elseif shapeType == 'custom' then
            if optionalVertices then
                local polygon = optionalVertices
                --print(inspect(polygon))
                shapesList = makeShapeListFromPolygon(polygon) or {}
                --print('shapelist size:', #shapesList)
                vertices = polygon
                --print('numvertices', #vertices)
            else
                error('shapetype custom needs optionalVertices!')
            end
        else
            --print(shapeType, radius, width, height, optionalVertices)
            error("Unknown shape type: " .. tostring(shapeType))
        end
    end
    return shapesList, vertices
end

return shapes
-- ui-all.lua
local ui = {}

require('src.ui-textinput')(ui)

-- Theme Configuration
local theme = {
    button = {
        default = { 188 / 255, 175 / 255, 156 / 255 },   -- Default fill color
        hover = { 105 / 255, 98 / 255, 109 / 255 },      -- Hover fill color
        pressed = { 217 / 255, 189 / 255, 197 / 255 },   -- Pressed fill color
        outline = { 1, 1, 1 },                           -- Outline color
        text_default = { 1, 1, 1 },                      -- Default text color
        text_hover = { 244 / 255, 189 / 255, 94 / 255 }, -- Text color on hover
        radius = 2,
        height = 34
    },
    checkbox = {
        checked = { 1, 1, 1 },
        label = { 1, 1, 1 }, -- Label text color
    },
    toggleButton = {
        onFill = { 0.2, 0.8, 0.2 },  -- Green fill when toggled on
        offFill = { 0.8, 0.2, 0.2 }, -- Red fill when toggled off
        onText = { 1, 1, 1 },        -- Text color when toggled on
        offText = { 1, 1, 1 },       -- Text color when toggled off
        outline = { 1, 1, 1 },       -- Outline color
    },
    slider = {
        track = { 0.5, 0.5, 0.5 }, -- Slider track color
        thumb = { 0.2, 0.6, 1 },   -- Slider thumb color
        outline = { 1, 1, 1 },
        track_radius = 2,
        height = 32
    },
    draggedElement = {
        fill = { 1, 1, 1 }, -- Color of the dragged element
    },
    general = {
        text = { 1, 1, 1 }, -- General text color
    },
    panel = {
        background = { 50 / 255, 50 / 255, 50 / 255 }, -- Panel background color
        outline = { 1, 1, 1 },                         -- Panel outline color
        label = { 1, 1, 1 },                           -- Panel label text color
    },
    textinput = {
        background = { 0.1, 0.1, 0.1 },                          -- Background color of the TextInput
        outline = { 1, 1, 1 },                                   -- Default outline color
        text = { 1, 1, 1 },                                      -- Text color
        placeholder = { 0.5, 0.5, 0.5 },                         -- Placeholder text color
        cursor = { 1, 1, 1 },                                    -- Cursor color
        focusedBorderColor = { 244 / 255, 189 / 255, 94 / 255 }, -- Border color when focused
        selectionBackground = { 0.2, 0.4, 0.8, 0.5 },            -- Selection highlight color
    },
    lineWidth = 3,                                               -- General line width
}

ui.theme = theme

--- Initializes the UI module.
function ui.init(font)
    ui.nextID = 1               -- Unique ID counter
    ui.dragOffset = { x = 0, y = 0 }
    ui.focusedTextInputID = nil -- Tracks the currently focused TextInput
    ui.textInputs = {}
    ui.font = font or love.graphics.getFont()
end

--- Resets UI state at the start of each frame.
function ui.startFrame()
    ui.nextID = 1           -- Reset unique ID counter at the start of each frame

    ui.mousePressed = false -- Reset click state
    ui.mouseReleased = false

    local down = love.mouse.isDown(1)
    if not ui.mouseIsDown and down then
        ui.mousePressed = true
    end
    if ui.mouseIsDown and not down then
        ui.mouseReleased = true
    end
    ui.mouseIsDown = down

    ui.mouseX, ui.mouseY = love.mouse.getPosition()
end

function ui.generateID()
    local id = ui.nextID
    ui.nextID = ui.nextID + 1
    return id
end

--- Creates a layout context for arranging UI elements.
function ui.createLayout(params)
    local layout = {
        type = params.type or 'rows',
        margin = params.margin or 0,
        spacing = params.spacing or 0,
        curX = params.startX or 0,
        curY = params.startY or 0,
    }
    return layout
end

--- Calculates the next position in the layout and updates the layout context.
function ui.nextLayoutPosition(layout, elementWidth, elementHeight)
    local x = layout.curX
    local y = layout.curY

    -- Update positions for the next element
    if layout.type == 'rows' then
        layout.curX = layout.curX + elementWidth + layout.spacing
    elseif layout.type == 'columns' then
        layout.curY = layout.curY + elementHeight + layout.spacing
    end

    return x, y
end

--- Creates a horizontal slider with a numeric input field.
function ui.sliderWithInput(_id, x, y, w, min, max, value, changed)
    local yOffset = (40 - theme.slider.height) / 2
    local panelSlider = ui.slider(x, y + yOffset, w, ui.theme.slider.height, 'horizontal', min, max, value, _id)
    local valueHasChangedViaSlider = false
    local returnValue = nil

    if panelSlider then
        value = string.format("%.2f", panelSlider)
        valueHasChangedViaSlider = true
        returnValue = value
    end

    local valueChangeFromOutside = valueHasChangedViaSlider or changed

    -- TextInput for numeric input
    local numericInputText, dirty = ui.textinput(_id, x + w + 10, y, 90, 40, "Enter number...", "" .. value,
        true, valueChangeFromOutside)


    if dirty then
        value = tonumber(numericInputText)
        returnValue = value
    end
    --print(valueHasChangedViaSlider, changed, dirty)
    if returnValue then
        return returnValue
    end
end

--- Draws a panel with optional label and content.
function ui.panel(x, y, width, height, label, drawFunc)
    -- Draw panel background
    --
    --
    local rxry = 0
    if theme.button.radius > 0 then
        rxry = math.min(width / 6, height / 6) / theme.button.radius
    end
    love.graphics.setColor(theme.panel.background)
    love.graphics.rectangle("fill", x, y, width, height, rxry, rxry)

    -- Draw panel outline
    love.graphics.setColor(theme.panel.outline)
    love.graphics.setLineWidth(theme.lineWidth)
    love.graphics.rectangle("line", x, y, width, height, rxry, rxry)

    -- Draw panel label if provided
    if label then
        love.graphics.setColor(theme.panel.label)
        local labelHeight = ui.font:getHeight()
        love.graphics.printf(label, x, y + 5, width, "center")
    end

    -- Enable scissor to clip UI elements within the panel
    love.graphics.setScissor(x, y, width, height)

    -- Call the provided draw function to render UI elements inside the panel
    if drawFunc then
        drawFunc()
    end

    -- Disable scissor
    love.graphics.setScissor()

    -- Reset color to white
    love.graphics.setColor(1, 1, 1)
end

--- Creates a checkbox with a label.
function ui.checkbox(x, y, checked, label)
    local size = theme.slider.height
    -- Determine the label to display inside the checkbox
    local checkmark = checked and "x" or ""

    -- Render the checkbox square using the existing button function
    local clicked, pressed, released = ui.button(x, y, size, '', size)

    -- Toggle the checked state if the checkbox was clicked
    if clicked then
        checked = not checked
    end
    local radius = size / 4
    if checked then
        love.graphics.setColor(theme.checkbox.checked) -- Use checkbox's checked color
        love.graphics.circle('fill', x + size / 2, y + size / 2, radius)
    end
    -- Draw the label text next to the checkbox
    love.graphics.setColor(theme.checkbox.label)       -- Label text color
    local textY = y + (size - ui.font:getHeight()) / 2 -- Vertically center the text
    love.graphics.print(label, x + size + 10, textY)

    -- Reset color to white
    love.graphics.setColor(1, 1, 1)

    -- Return the updated checked state
    return clicked, checked
end

--- Creates a toggle button that maintains an on/off state.
--- however i like the checkbox better though.......
function ui.toggleButton(x, y, width, height, labelOn, labelOff, isToggled)
    local id = ui.generateID()
    local isHover = ui.mouseX >= x and ui.mouseX <= x + width and
        ui.mouseY >= y and ui.mouseY <= y + height
    local pressed = isHover and ui.mousePressed

    if pressed then
        ui.activeElementID = id
    end

    -- Toggle state handling
    local used = false
    if ui.activeElementID == id and ui.mouseReleased and isHover then
        isToggled = not isToggled
        ui.activeElementID = nil
        used = true
    end

    -- Determine the label and colors based on the toggle state
    local label = isToggled and labelOn or labelOff
    local fillColor = isToggled and ui.theme.toggleButton.onFill or ui.theme.toggleButton.offFill
    local textColor = isToggled and ui.theme.toggleButton.onText or ui.theme.toggleButton.offText

    local rxry = 0
    if theme.button.radius > 0 then
        rxry = math.min(width, height) / theme.button.radius
    end
    -- Draw the button background
    love.graphics.setColor(fillColor)
    love.graphics.rectangle("fill", x, y, width, height, rxry, rxry)

    -- Draw button outline
    love.graphics.setColor(ui.theme.toggleButton.outline)
    love.graphics.setLineWidth(ui.theme.lineWidth)
    love.graphics.rectangle("line", x, y, width, height, rxry, rxry)

    -- Draw the label
    love.graphics.setColor(textColor)
    local textHeight = ui.font:getHeight()
    love.graphics.printf(label, x, y + (height - textHeight) / 2, width, "center")

    -- Reset color
    love.graphics.setColor(1, 1, 1)

    return used, isToggled
end

--- Creates a button.
function ui.button(x, y, width, label, optionalHeight)
    local height = optionalHeight and optionalHeight or theme.button.height

    local id = ui.generateID() -- Generate unique ID
    local isHover = ui.mouseX >= x and ui.mouseX <= x + width and
        ui.mouseY >= y and ui.mouseY <= y + height
    local pressed = isHover and ui.mousePressed

    if pressed then
        ui.activeElementID = id
    end
    -- Draw the button with state-based colors
    if ui.activeElementID == id then
        love.graphics.setColor(theme.button.pressed) -- Pressed state
    elseif isHover then
        love.graphics.setColor(theme.button.hover)   -- Hover state
    else
        love.graphics.setColor(theme.button.default) -- Default state
    end
    local rxry = 0
    if theme.button.radius > 0 then
        rxry = math.min(width, height) / theme.button.radius
    end

    love.graphics.rectangle("fill", x, y, width, height, rxry, rxry)

    -- Draw button outline
    love.graphics.setColor(theme.button.outline) -- Outline color
    love.graphics.setLineWidth(theme.lineWidth)
    love.graphics.rectangle("line", x, y, width, height, rxry, rxry)

    -- Draw button label with state-based color
    if isHover then
        love.graphics.setColor(theme.button.text_hover)   -- Text color on hover
    else
        love.graphics.setColor(theme.button.text_default) -- Default text color
    end
    local textHeight = ui.font:getHeight()
    love.graphics.printf(label, x, y + (height - textHeight) / 2, width, "center")

    -- Reset color
    love.graphics.setColor(1, 1, 1)

    local clicked = false
    local released = ui.mouseReleased and ui.activeElementID == id

    if ui.activeElementID == id and released and isHover then
        clicked = true
    end
    if released then
        -- Reset the active element ID
        ui.activeElementID = nil
    end
    return clicked, pressed, released
end

--- Creates a slider (horizontal or vertical).
function ui.slider(x, y, length, thickness, orientation, min, max, value, extraId)
    local inValue = value
    local sliderID = ui.generateID()
    if (extraId) then
        sliderID = sliderID .. extraId
    end
    local isHorizontal = orientation == 'horizontal'

    -- Calculate proportion and initial thumb position
    local proportion = (value - min) / (max - min)
    local thumbX, thumbY
    if isHorizontal then
        thumbX = x + proportion * (length - thickness)
        thumbY = y
    else
        thumbX = x
        thumbY = y + (1 - proportion) * (length - thickness)
    end

    -- Render the track
    love.graphics.setColor(theme.slider.track) -- Slider track color

    local rxry = 0
    if theme.slider.track_radius > 0 then
        rxry = math.min(length, thickness) / theme.slider.track_radius
    end
    if isHorizontal then
        love.graphics.rectangle("fill", x, y, length, thickness, rxry, rxry)
    else
        love.graphics.rectangle("fill", x, y, thickness, length, rxry, rxry)
    end

    -- Draw track outline
    love.graphics.setColor(theme.slider.outline) -- Slider track outline color
    love.graphics.setLineWidth(theme.lineWidth)
    if isHorizontal then
        love.graphics.rectangle("line", x, y, length, thickness, rxry, rxry)
    else
        love.graphics.rectangle("line", x, y, thickness, length, rxry, rxry)
    end


    -- Set scissor to restrict rendering to the track area
    love.graphics.setScissor(x, y, isHorizontal and length or thickness, isHorizontal and thickness or length)

    -- Render the thumb using the existing button function
    local thumbLabel = ''
    local clicked, pressed, released = ui.button(thumbX, thumbY, thickness, thumbLabel, thickness)

    -- Remove scissor after rendering the thumb
    love.graphics.setScissor()



    -- -- Render the thumb using the existing button function
    -- local thumbLabel = ''
    -- local clicked, pressed, released = ui.button(thumbX, thumbY, thickness, thumbLabel, thickness)

    -- Handle dragging
    if pressed then
        ui.draggingSliderID = sliderID
        -- Calculate and store the offset
        if isHorizontal then
            ui.dragOffset.x = ui.mouseX - thumbX
            ui.dragOffset.y = 0 -- Not needed for horizontal
        else
            ui.dragOffset.x = 0 -- Not needed for vertical
            ui.dragOffset.y = ui.mouseY - thumbY
        end
    end

    if ui.draggingSliderID == sliderID then
        local mouseX, mouseY = ui.mouseX, ui.mouseY
        if isHorizontal then
            -- Clamp thumbX within the track boundaries
            thumbX = math.max(x, math.min(mouseX - ui.dragOffset.x, x + length - thickness))
            proportion = (thumbX - x) / (length - thickness)
        else
            -- Clamp thumbY within the track boundaries
            thumbY = math.max(y, math.min(mouseY - ui.dragOffset.y, y + length - thickness))
            proportion = 1 - ((thumbY - y) / (length - thickness))
        end

        value = min + proportion * (max - min)
    end

    if released and ui.draggingSliderID == sliderID then
        ui.draggingSliderID = nil
        -- Reset the drag offset
        ui.dragOffset.x = 0
        ui.dragOffset.y = 0
    end
    -- Reset color
    love.graphics.setColor(1, 1, 1)

    -- Return the updated value if it has changed
    if inValue ~= value then
        return value
    else
        return false
    end
end

--- Handles text input for the UI, particularly for text inputs.
function ui.handleTextInput(t)
    local textinputstate = ui.focusedTextInputID and ui.textInputs[ui.focusedTextInputID]
    if textinputstate then
        ui.handleTextInputForTextInput(t, textinputstate)
    end
end

--- Handles key presses for the UI, particularly for text inputs.
function ui.handleKeyPress(key)
    local textinputstate = ui.focusedTextInputID and ui.textInputs[ui.focusedTextInputID]

    if textinputstate then
        ui.handleKeyPressForTextInput(key, textinputstate)
    end
end

--- Draws a text label at the specified position.
function ui.centeredLabel(x, y, width, text)
    love.graphics.setColor(ui.theme.general.text)
    --  love.graphics.print(text, x, y)
    love.graphics.printf(text, x, y, width, "center")
    love.graphics.setColor(1, 1, 1)
end

function ui.label(x, y, text)
    love.graphics.setColor(ui.theme.general.text)
    love.graphics.print(text, x, y)
    love.graphics.setColor(1, 1, 1)
end

--- Creates a dropdown menu.
function ui.dropdown(x, y, width, options, currentSelection)
    local id = ui.generateID()
    local isOpen = ui.dropdownStates and ui.dropdownStates[id] or false
    -- Draw the dropdown box
    local clicked, pressed, released = ui.button(x, y, width, currentSelection)

    -- Toggle dropdown state
    if clicked then
        isOpen = not isOpen
    end
    ui.dropdownStates = ui.dropdownStates or {}
    ui.dropdownStates[id] = isOpen

    -- Draw options if open
    if isOpen then
        for i, option in ipairs(options) do
            local optionY = y + i * (theme.button.height + 10)
            local optionClicked = ui.button(x + width, optionY, width, option)
            if optionClicked then
                currentSelection = option
                ui.dropdownStates[id] = false -- Close dropdown
                return currentSelection
            end
        end
    end
    return false, pressed, released
end

return ui
--ui-text-input.lua
return function(ui)
    --- Helper function to calculate cursor position within a line based on mouse X coordinate.
    function ui.calculateCursorPositionInLine(text, relativeX)
        local newCursorPosition = 0
        for i = 1, #text do
            local subText = text:sub(1, i)
            local textWidth = ui.font:getWidth(subText)
            if textWidth > relativeX then
                newCursorPosition = i - 1
                break
            end
        end
        if relativeX > ui.font:getWidth(text) then
            newCursorPosition = #text
        end
        return newCursorPosition
    end

    --- Function to reconstruct the text from lines.
    function ui.reconstructText(lines)
        return table.concat(lines, "\n")
    end

    --- Function to split text into lines.
    function ui.splitTextIntoLines(text)
        local lines = {}
        for line in (text .. "\n"):gmatch("(.-)\n") do
            table.insert(lines, line)
        end
        return lines
    end

    --- Function to check if the selection is empty.
    function ui.isSelectionEmpty(state)
        return state.selectionStart.line == state.selectionEnd.line and
            state.selectionStart.char == state.selectionEnd.char
    end

    --- Function to get the selected text.
    function ui.getSelectedText(state)
        local selStartLine = state.selectionStart.line
        local selStartChar = state.selectionStart.char
        local selEndLine = state.selectionEnd.line
        local selEndChar = state.selectionEnd.char

        -- Normalize selection indices
        if selStartLine > selEndLine or (selStartLine == selEndLine and selStartChar > selEndChar) then
            selStartLine, selEndLine = selEndLine, selStartLine
            selStartChar, selEndChar = selEndChar, selStartChar
        end

        local selectedText = {}
        for i = selStartLine, selEndLine do
            local lineText = state.lines[i]
            local startChar = (i == selStartLine) and selStartChar + 1 or 1
            local endChar = (i == selEndLine) and selEndChar or #lineText
            table.insert(selectedText, lineText:sub(startChar, endChar))
        end
        return table.concat(selectedText, "\n")
    end

    --- Function to delete the selected text.
    function ui.deleteSelection(state)
        local selStartLine = state.selectionStart.line
        local selStartChar = state.selectionStart.char
        local selEndLine = state.selectionEnd.line
        local selEndChar = state.selectionEnd.char

        -- Normalize selection indices
        if selStartLine > selEndLine or (selStartLine == selEndLine and selStartChar > selEndChar) then
            selStartLine, selEndLine = selEndLine, selStartLine
            selStartChar, selEndChar = selEndChar, selStartChar
        end

        if selStartLine == selEndLine then
            -- Selection within a single line
            local line = state.lines[selStartLine]
            state.lines[selStartLine] = line:sub(1, selStartChar) .. line:sub(selEndChar + 1)
        else
            -- Selection spans multiple lines
            local startLineText = state.lines[selStartLine]:sub(1, selStartChar)
            local endLineText = state.lines[selEndLine]:sub(selEndChar + 1)
            -- Remove middle lines
            for i = selStartLine + 1, selEndLine do
                table.remove(state.lines, selStartLine + 1)
            end
            -- Merge start and end lines
            state.lines[selStartLine] = startLineText .. endLineText
        end
        -- Update cursor position
        state.cursorPosition = { line = selStartLine, char = selStartChar }
        -- Clear selection
        state.selectionStart = { line = selStartLine, char = selStartChar }
        state.selectionEnd = { line = selStartLine, char = selStartChar }
        -- Reconstruct text
        state.text = ui.reconstructText(state.lines)
    end

    --- Helper function to calculate cursor position based on mouse X coordinate.
    function ui.calculateCursorPosition(text, relativeX)
        local newCursorPosition = 0
        for i = 1, #text do
            local subText = text:sub(1, i)
            local textWidth = ui.font:getWidth(subText)
            if textWidth > relativeX then
                newCursorPosition = i - 1
                break
            end
        end
        if relativeX > ui.font:getWidth(text) then
            newCursorPosition = #text
        end
        return newCursorPosition
    end

    function ui.handleTextInputForTextInput(t, state)
        -- local state = ui.textInputs[ui.focusedTextInputID]

        if state.isNumeric and not tonumber(t) and t ~= "." and t ~= "-" then
            -- Ignore non-numeric input
            return
        end

        if not ui.isSelectionEmpty(state) then
            ui.deleteSelection(state)
        end

        local pos = state.cursorPosition
        local line = state.lines[pos.line]
        if t == "\n" or t == "\r" then
            -- Handle new line
            local beforeCursor = line:sub(1, pos.char)
            local afterCursor = line:sub(pos.char + 1)
            state.lines[pos.line] = beforeCursor
            table.insert(state.lines, pos.line + 1, afterCursor)
            pos.line = pos.line + 1
            pos.char = 0
        else
            -- Regular character input
            state.lines[pos.line] = line:sub(1, pos.char) .. t .. line:sub(pos.char + 1)
            pos.char = pos.char + #t
        end
        -- Update selection
        state.selectionStart = { line = pos.line, char = pos.char }
        state.selectionEnd = { line = pos.line, char = pos.char }
        -- Reconstruct text
        state.text = ui.reconstructText(state.lines)
    end

    function ui.handleKeyPressForTextInput(key, state)
        -- local state = ui.textInputs[ui.focusedTextInputID]
        local isCtrlDown = love.keyboard.isDown('lctrl', 'rctrl')
        local isShiftDown = love.keyboard.isDown('lshift', 'rshift')
        local isCMDDown = love.keyboard.isDown('lgui', 'rgui')
        if isCtrlDown or isCMDDown then
            if key == 'c' then
                -- Copy
                if not ui.isSelectionEmpty(state) then
                    local selectedText = ui.getSelectedText(state)
                    love.system.setClipboardText(selectedText)
                end
            elseif key == 'v' then
                -- Paste
                local clipboardText = love.system.getClipboardText() or ""
                if clipboardText ~= "" then
                    -- Delete selected text if any
                    if not ui.isSelectionEmpty(state) then
                        ui.deleteSelection(state)
                    end
                    -- Insert clipboard text
                    local pos = state.cursorPosition
                    local linesToInsert = ui.splitTextIntoLines(clipboardText)
                    if #linesToInsert == 1 then
                        -- Insert into current line
                        local line = state.lines[pos.line]
                        state.lines[pos.line] = line:sub(1, pos.char) .. linesToInsert[1] .. line:sub(pos.char + 1)
                        pos.char = pos.char + #linesToInsert[1]
                    else
                        -- Insert multiple lines
                        local line = state.lines[pos.line]
                        local beforeCursor = line:sub(1, pos.char)
                        local afterCursor = line:sub(pos.char + 1)
                        state.lines[pos.line] = beforeCursor .. linesToInsert[1]
                        for i = 2, #linesToInsert - 1 do
                            table.insert(state.lines, pos.line + i - 1, linesToInsert[i])
                        end
                        table.insert(state.lines, pos.line + #linesToInsert - 1,
                            linesToInsert[#linesToInsert] .. afterCursor)
                        pos.line = pos.line + #linesToInsert - 1
                        pos.char = #linesToInsert[#linesToInsert]
                    end
                    -- Clear selection
                    state.selectionStart = { line = pos.line, char = pos.char }
                    state.selectionEnd = { line = pos.line, char = pos.char }
                    -- Reconstruct text
                    state.text = ui.reconstructText(state.lines)
                end
            elseif key == 'x' then
                -- Cut
                if not ui.isSelectionEmpty(state) then
                    local selectedText = ui.getSelectedText(state)
                    love.system.setClipboardText(selectedText)
                    ui.deleteSelection(state)
                end
            end
        else
            -- Handle other keys
            local pos = state.cursorPosition
            if key == "backspace" then
                if not ui.isSelectionEmpty(state) then
                    ui.deleteSelection(state)
                elseif pos.char > 0 then
                    -- Delete character before cursor
                    local line = state.lines[pos.line]
                    state.lines[pos.line] = line:sub(1, pos.char - 1) .. line:sub(pos.char + 1)
                    pos.char = pos.char - 1
                elseif pos.line > 1 then
                    -- Merge with previous line
                    local prevLine = state.lines[pos.line - 1]
                    pos.char = #prevLine
                    state.lines[pos.line - 1] = prevLine .. state.lines[pos.line]
                    table.remove(state.lines, pos.line)
                    pos.line = pos.line - 1
                end
                -- Update selection
                state.selectionStart = { line = pos.line, char = pos.char }
                state.selectionEnd = { line = pos.line, char = pos.char }
                state.text = ui.reconstructText(state.lines)
            elseif key == "delete" then
                if not ui.isSelectionEmpty(state) then
                    ui.deleteSelection(state)
                elseif pos.char < #state.lines[pos.line] then
                    -- Delete character after cursor
                    local line = state.lines[pos.line]
                    state.lines[pos.line] = line:sub(1, pos.char) .. line:sub(pos.char + 2)
                elseif pos.line < #state.lines then
                    -- Merge with next line
                    state.lines[pos.line] = state.lines[pos.line] .. state.lines[pos.line + 1]
                    table.remove(state.lines, pos.line + 1)
                end
                -- Update selection
                state.selectionStart = { line = pos.line, char = pos.char }
                state.selectionEnd = { line = pos.line, char = pos.char }
                state.text = ui.reconstructText(state.lines)
            elseif key == "left" then
                if pos.char > 0 then
                    pos.char = pos.char - 1
                elseif pos.line > 1 then
                    pos.line = pos.line - 1
                    pos.char = #state.lines[pos.line]
                end
                if isShiftDown then
                    state.selectionEnd = { line = pos.line, char = pos.char }
                else
                    state.selectionStart = { line = pos.line, char = pos.char }
                    state.selectionEnd = { line = pos.line, char = pos.char }
                end
            elseif key == "right" then
                if pos.char < #state.lines[pos.line] then
                    pos.char = pos.char + 1
                elseif pos.line < #state.lines then
                    pos.line = pos.line + 1
                    pos.char = 0
                end
                if isShiftDown then
                    state.selectionEnd = { line = pos.line, char = pos.char }
                else
                    state.selectionStart = { line = pos.line, char = pos.char }
                    state.selectionEnd = { line = pos.line, char = pos.char }
                end
            elseif key == "up" then
                if pos.line > 1 then
                    pos.line = pos.line - 1
                    pos.char = math.min(pos.char, #state.lines[pos.line])
                end
                if isShiftDown then
                    state.selectionEnd = { line = pos.line, char = pos.char }
                else
                    state.selectionStart = { line = pos.line, char = pos.char }
                    state.selectionEnd = { line = pos.line, char = pos.char }
                end
            elseif key == "down" then
                if pos.line < #state.lines then
                    pos.line = pos.line + 1
                    pos.char = math.min(pos.char, #state.lines[pos.line])
                end
                if isShiftDown then
                    state.selectionEnd = { line = pos.line, char = pos.char }
                else
                    state.selectionStart = { line = pos.line, char = pos.char }
                    state.selectionEnd = { line = pos.line, char = pos.char }
                end
            elseif key == "home" then
                pos.char = 0
                if isShiftDown then
                    state.selectionEnd = { line = pos.line, char = pos.char }
                else
                    state.selectionStart = { line = pos.line, char = pos.char }
                    state.selectionEnd = { line = pos.line, char = pos.char }
                end
            elseif key == "end" then
                pos.char = #state.lines[pos.line]
                if isShiftDown then
                    state.selectionEnd = { line = pos.line, char = pos.char }
                else
                    state.selectionStart = { line = pos.line, char = pos.char }
                    state.selectionEnd = { line = pos.line, char = pos.char }
                end
            elseif key == "return" or key == "kpenter" then
                -- Handle new line on enter key
                --ui.handleTextInput("\n")
                ui.handleTextInputForTextInput("\n", state)
            elseif key == "escape" then
                ui.focusedTextInputID = nil
            end
        end
    end

    function ui.textinput(_id, x, y, width, height, placeholder, currentText, isNumeric, reparse)
        local id = _id or ui.generateID()
        --print(id, currentText)
        -- Initialize state for this TextInput if not already done
        if not ui.textInputs[id] then
            ui.textInputs[id] = {
                text = currentText or "",
                lines = {}, -- Stores text broken into lines
                cursorPosition = { line = 1, char = 0 },
                cursorTimer = 0,
                cursorVisible = true,
                isNumeric = isNumeric or false,
                selectionStart = { line = 1, char = 0 },
                selectionEnd = { line = 1, char = 0 },
                isSelecting = false,
            }
            -- Split initial text into lines
            ui.textInputs[id].lines = ui.splitTextIntoLines(ui.textInputs[id].text)
        end

        local state = ui.textInputs[id]

        if reparse then
            state.text = currentText
            state.lines = ui.splitTextIntoLines(state.text)
        end

        local isHover = ui.mouseX >= x and ui.mouseX <= x + width and
            ui.mouseY >= y and ui.mouseY <= y + height

        -- Handle focus and cursor positioning
        if ui.mousePressed then
            if isHover then
                ui.focusedTextInputID = id

                local relativeX = ui.mouseX - x - 5 -- Subtracting padding
                local relativeY = ui.mouseY - y
                local lineIndex = math.floor(relativeY / ui.font:getHeight()) + 1
                lineIndex = math.max(1, math.min(lineIndex, #state.lines))
                local lineText = state.lines[lineIndex]
                local charIndex = ui.calculateCursorPositionInLine(lineText, relativeX)
                state.cursorPosition = { line = lineIndex, char = charIndex }
                state.selectionStart = { line = lineIndex, char = charIndex }
                state.selectionEnd = { line = lineIndex, char = charIndex }
                state.isSelecting = true
            else
                if ui.focusedTextInputID == id then
                    ui.focusedTextInputID = nil
                end
            end
        end

        -- Handle text selection with mouse dragging
        if ui.focusedTextInputID == id and ui.mouseIsDown and state.isSelecting then
            local relativeX = ui.mouseX - x - 5
            local relativeY = ui.mouseY - y
            local lineIndex = math.floor(relativeY / ui.font:getHeight()) + 1
            lineIndex = math.max(1, math.min(lineIndex, #state.lines))
            local lineText = state.lines[lineIndex]
            local charIndex = ui.calculateCursorPositionInLine(lineText, relativeX)
            state.cursorPosition = { line = lineIndex, char = charIndex }
            state.selectionEnd = { line = lineIndex, char = charIndex }
        elseif ui.mouseReleased and state.isSelecting then
            state.isSelecting = false
        end

        -- Check if this TextInput is focused
        local isFocused = (ui.focusedTextInputID == id)

        -- Update cursor blinking
        if isFocused then
            --  print(love.timer.getDelta())
            state.cursorTimer = state.cursorTimer + 1.0 / 90 --love.timer.getDelta()
            if state.cursorTimer >= 0.5 then
                state.cursorVisible = not state.cursorVisible
                state.cursorTimer = 0
            end
        else
            state.cursorVisible = false
            state.cursorTimer = 0
        end

        -- Draw TextInput background
        love.graphics.setColor(ui.theme.textinput.background)
        love.graphics.rectangle("fill", x, y, width, height, ui.theme.button.radius, ui.theme.button.radius)

        -- Draw TextInput outline
        if isFocused then
            love.graphics.setColor(ui.theme.textinput.focusedBorderColor)
        else
            love.graphics.setColor(ui.theme.textinput.outline)
        end
        love.graphics.setLineWidth(ui.theme.lineWidth)
        love.graphics.rectangle("line", x, y, width, height, ui.theme.button.radius, ui.theme.button.radius)

        local lineHeight = ui.font:getHeight()

        -- Set up scissor to clip text inside the TextInput area
        love.graphics.setScissor(x, y, width, height)

        -- Draw selection background
        local selStartLine = state.selectionStart.line
        local selStartChar = state.selectionStart.char
        local selEndLine = state.selectionEnd.line
        local selEndChar = state.selectionEnd.char

        -- Normalize selection indices
        if selStartLine > selEndLine or (selStartLine == selEndLine and selStartChar > selEndChar) then
            selStartLine, selEndLine = selEndLine, selStartLine
            selStartChar, selEndChar = selEndChar, selStartChar
        end

        if not (selStartLine == selEndLine and selStartChar == selEndChar) then
            for i = selStartLine, selEndLine do
                local lineText = state.lines[i]
                local startChar = (i == selStartLine) and selStartChar or 0
                local endChar = (i == selEndLine) and selEndChar or #lineText
                local selectionWidth = ui.font:getWidth(lineText:sub(startChar + 1, endChar))
                local selectionX = x + 5 + ui.font:getWidth(lineText:sub(1, startChar))
                local selectionY = y + (i - 1) * lineHeight
                love.graphics.setColor(ui.theme.textinput.selectionBackground)
                love.graphics.rectangle('fill', selectionX, selectionY, selectionWidth, lineHeight)
            end
        end

        -- Draw text
        for i, line in ipairs(state.lines) do
            local textY = y + (i - 1) * lineHeight
            love.graphics.setColor(ui.theme.textinput.text)
            love.graphics.print(line, x + 5, textY)
        end

        -- Draw cursor if focused
        if isFocused and state.cursorVisible then
            local pos = state.cursorPosition
            local lineText = state.lines[pos.line]:sub(1, pos.char)
            local cursorX = x + 5 + ui.font:getWidth(lineText)
            local cursorY = y + (pos.line - 1) * lineHeight
            love.graphics.setColor(ui.theme.textinput.cursor)
            love.graphics.line(cursorX, cursorY, cursorX, cursorY + lineHeight)
        end

        -- Remove scissor
        love.graphics.setScissor()

        -- Reset color
        love.graphics.setColor(1, 1, 1)

        return state.text, state.text ~= currentText
    end
end
--return ui
local lib = {}
-- Utility function to concatenate two tables.


function lib.trace(...)
    local info = debug.getinfo(2, "Sl")
    local t = { info.short_src .. ":" .. info.currentline .. ":" }
    for i = 1, select("#", ...) do
        local x = select(i, ...)
        if type(x) == "number" then
            x = string.format("%g", lib.round_to_decimals(x, 2))
        end
        t[#t + 1] = tostring(x)
    end
    print(table.concat(t, " "))
end

function lib.sanitizeString(input)
    if not input then return "" end   -- Handle nil or empty strings
    return input:gsub("[%c%s]+$", "") -- Remove control characters and trailing spaces
end

function lib.round_to_decimals(num, dec)
    local multiplier = 10 ^ dec -- 10^4 for 4 decimal places
    return math.floor(num * multiplier + 0.5) / multiplier
end

function lib.tablelength(T)
    local count = 0
    for _ in pairs(T) do count = count + 1 end
    return count
end

function lib.printTableKeys(tbl)
    for key, _ in pairs(tbl) do
        print(key)
    end
end

function lib.tableConcat(t1, t2)
    for i = 1, #t2 do
        table.insert(t1, t2[i])
    end
    return t1
end

function lib.shallowCopy(original)
    local copy = {}
    for key, value in pairs(original) do
        copy[key] = value
    end
    return copy
end

-- Function to compare two tables for equality (assuming they are arrays of numbers)
function lib.tablesEqualNumbers(t1, t2)
    -- Check if both tables have the same number of elements
    if #t1 ~= #t2 then
        return false
    end

    -- Compare each corresponding element
    for i = 1, #t1 do
        if t1[i] ~= t2[i] then
            return false
        end
    end

    return true
end

return lib
--uuid.lua
local random = love.math.random
local lib = {}
function lib.uuid128()
    local template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
    return (string.gsub(template, '[xy]', function(c)
        local v = (c == 'x') and random(0, 0xf) or random(8, 0xb)
        return string.format('%x', v)
    end))
end

-- Base62 character set
local base62_chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
-- Function to encode a number into Base62
function lib.base62_encode(num)
    local result = ""
    local base = 62
    repeat
        local remainder = num % base
        result = string.sub(base62_chars, remainder + 1, remainder + 1) .. result
        num = math.floor(num / base)
    until num == 0
    return result
end

-- Example: Encode a random 64-bit number
function lib.uuid64_base62()
    -- Generate a random 64-bit integer
    local num = love.math.random(0, 0xffffffff) * 0x100000000 + love.math.random(0, 0xffffffff)
    return lib.base62_encode(num)
end

function lib.uuid32_base62()
    local num = love.math.random(0, 0xffffffff) -- Generate a 32-bit random integer
    return lib.base62_encode(num)
end

function lib.uuid()
    return lib.uuid32_base62()
    --return lib.uuid128()
end

function lib.generateID()
    return lib.uuid()
end

return lib
